<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Performance: C&#x2B;&#x2B;/CLI vs COM - Paul Knopf</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="/dist/styles.css" rel="stylesheet" type="text/css"/>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112478642-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-112478642-1');
  </script>
</head>
<body>
<header class="bg-light mb-3">
  <div class="navbar navbar-expand">
    <div class="container">
      <a href="/" class="navbar-brand d-flex">
        <strong>paul knopf</strong>
      </a>
      <ul class="navbar-nav">
          <li class="nav-item">
              <a class="nav-link" href="https://speaker.pknopf.com/">my speaker</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/lit">lit</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/archive">archive</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/about">about</a>
          </li>
      </ul>
    </div>
  </div>
</header>
<main>
  
<div class="container">
    <div class="post">
        <h1 class="title">
            Performance: C&#x2B;&#x2B;/CLI vs COM
        </h1>
        <p class="submitted">
            posted on Mar 07, 2013
        </p>
        <div class="content">
            <p>In my current project, we are going to require a great deal of native code due to interation with drivers and hardware. The application is going to be based in .NET, at least the UI portion, but the heart has to live in native C++.</p>
<p>I began investigating different ways to interop with .NET and unmanaged code. There seems to be three approaches.</p>
<ul>
<li>PInvoke</li>
<li>COM/COM+/Interop</li>
<li>C++/CLI</li>
</ul>
<p>I did not look into the PInvoke method because I know that it will not be suitable for my needs. Things get complicated really quick with PInvoke. It is ideal for small/quick access to Win32, but not beyond that. With that said, I produced some metrics about the performance between COM+ and C++/CLI.</p>
<p>I have one class (unmanaged) that I use in every metric.</p>
<pre><code class="language-c++ hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span>
__declspec(dllexport) <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NativeClass</span>
{</span>
<span class="hljs-keyword">public</span>:
	__declspec(dllexport) NativeClass(<span class="hljs-keyword">void</span>);
	__declspec(dllexport) ~NativeClass(<span class="hljs-keyword">void</span>);
	__declspec(dllexport) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetWindowsVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numberOfExecutions)</span></span>;
};</code></pre>
<p>There are duplications of this class but they all do the same thing. The method we are testing is a simple GetVersionEx from the WinAPI.</p>
<pre><code class="language-c++ hljs"><span class="hljs-keyword">int</span> NativeClass::GetWindowsVersion(<span class="hljs-keyword">int</span> numberOfExecutions)
{
	OSVERSIONINFO osvi;

	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; numberOfExecutions; x++)
	{
		ZeroMemory(&amp;osvi, <span class="hljs-keyword">sizeof</span>(OSVERSIONINFO));
		osvi.dwOSVersionInfoSize = <span class="hljs-keyword">sizeof</span>(OSVERSIONINFO);
		GetVersionEx(&amp;osvi);
	}

	<span class="hljs-keyword">return</span> osvi.dwBuildNumber;
}</code></pre>
<p>The parameter “numberOfExecutions” tells the unmanaged class how many times it should invoke GetVersionEx. This native class is written/duplicated in multiple projects to similate the same process. I have 4 projects.</p>
<ol>
<li>PerformanceTest - This is a console application that runs the performance in C#/.NET</li>
<li>CLITest - This is a C++/CLI project that contains two classes. The first class is a wrapper around an unmanaged class that is compiled in the same C++/CLI project. The second class is a wrapper around an unmanaged class that is compiled in a seperate native dll (not C++/CLI).</li>
<li>COMTest - This is a project that has a COM wrapper around an unmanaged class.</li>
</ol>
<p>I tested two scenarios.</p>
<ol>
<li>Calling an unmanaged class from .NET multiple times.</li>
<li>Calling an unmanaged class from .NET a single time while doing a large task (numberOfExecutions = 10000000).</li>
</ol>
<p>Here are the results from the console application for the 3 situations.</p>
<ol>
<li>.NET to CLI calling an unmanaged class compiled in C++/CLI.</li>
<li>.NET to CLI calling an unmanaged class compiled in native C++.</li>
<li>.NET to COM calling an unmanaged class compiled in native C++.</li>
</ol>
<p>Here is the output of the test.</p>
<pre><code>CLI..........................
     GetWindowsVersion:
         Calls: 100000
         Executions: 1
         Result: 00:00:00.0190000
     GetWindowsVersion:
         Calls: 1
         Executions: 100000000
         Result: 00:00:15.7790000
CLI to native................
     GetWindowsVersion:
         Calls: 100000
         Executions: 1
         Result: 00:00:00.0180000
     GetWindowsVersion:
         Calls: 1
         Executions: 100000000
         Result: 00:00:04.8020000
COM..........................
     GetWindowsVersion:
         Calls: 100000
         Executions: 1
         Result: 00:00:02.6120000
     GetWindowsVersion:
         Calls: 1
         Executions: 100000000
         Result: 00:00:04.7310000
</code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>Native code compiled and running under C++/CLI is a great deal slower than running pure native code. COM would be the obviouse choice due to it running pure unmanaged code, but C++/CLI can give the same performance if used as a wrapper around a pure native assembly. In addition, COM/ATL is very difficult to learn, however, Visual Studio’s class wizards make it easier. Also, it seems that, making a great deal of calls to native code is MUCH more efficient through C++/CLI as opposed to COM, but this may be an unlikely scenario. Given these results and given the fact that this native code I am writing will be written primarily for .NET (as opposed to COM/activex/etc), I would recommend using the C++/CLI wrapper approach. Same performance, more flexible interop.</p>
<p>The project used for running these tests can be found on github <a href="https://github.com/theonlylawislove/CLICOMPerformanceTest">here</a>.</p>

        </div>
            <hr />
            <h3>Comments</h3>
                <p class="text-muted">
                    There are no comments yet.
                </p>
            <p class="text-center">
                <a class="btn btn-primary btn-light btn-lg" target="_blank" href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/5#new_comment_field"><i class="fab fa-github"></i> Join the discussion at GitHub</a>
            </p>
    </div>
</div>
</main>
<footer class="bg-light py-3 mt-5 text-muted text-center">
  <a href="https://github.com/pauldotknopf/pauldotknopf.github.io"><i class="fab fa-github"></i> source</a>
</footer>
<script src="/dist/scripts.js"></script>
</body>
</html>
