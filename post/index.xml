<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Paul Knopf</title>
    <link>https://www.pknopf.com/post/</link>
    <description>Recent content in Posts on Paul Knopf</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Aug 2018 11:36:35 -0500</lastBuildDate>
    
	<atom:link href="https://www.pknopf.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A new approach for cross-platform .NET GUI development, introducing Qml.Net.</title>
      <link>https://www.pknopf.com/post/2018-08-06-a-new-approach-for-cross-platform-net-gui-development-introducing-qml-net/</link>
      <pubDate>Mon, 06 Aug 2018 11:36:35 -0500</pubDate>
      
      <guid>https://www.pknopf.com/post/2018-08-06-a-new-approach-for-cross-platform-net-gui-development-introducing-qml-net/</guid>
      <description>Since Microsoft anounced .NET Core, there hasn&amp;rsquo;t been a clear vision vision on what cross-platform GUI development would look like. Although they plan to support WPF in .NET Core 3.0, it will still only target Windows.
There have been many different projects that have proped up that have attempted to fill the void, but (IMO) have come up short. They typically have one or more of the following issues:</description>
    </item>
    
    <item>
      <title>Introducing Darch, a tool for building immutable, reproducable, and stateless bootable Linux images. Think Docker, but for bare-metal.</title>
      <link>https://www.pknopf.com/post/2018-01-14-introducing_darch_a_tool_for_building_immutable_reproducable_stateless_linux_images_docker_for_base_metal/</link>
      <pubDate>Thu, 01 Feb 2018 11:36:35 -0500</pubDate>
      
      <guid>https://www.pknopf.com/post/2018-01-14-introducing_darch_a_tool_for_building_immutable_reproducable_stateless_linux_images_docker_for_base_metal/</guid>
      <description>I have previously blogged about my desire to have a &amp;ldquo;docker-like&amp;rdquo; environment for build images that I can boot bare-metal.
With that said, I created Darch.
What it is Darch is an application (written in golang) that makes building and booting rootfs images simple. It will generate rootfs.squash files and update grub.cfg for booting them. Even though Darch supports Arch only (Gentoo/VoidLinux soon), you can build and boot the images from any operating system that has grub installed.</description>
    </item>
    
    <item>
      <title>An immutable, reproducible and inheritable Linux operating system.</title>
      <link>https://www.pknopf.com/post/2017-03-20-an_immutable_reproducible_and_inheritable_linux_operating_system/</link>
      <pubDate>Wed, 20 Sep 2017 14:50:41 -0400</pubDate>
      
      <guid>https://www.pknopf.com/post/2017-03-20-an_immutable_reproducible_and_inheritable_linux_operating_system/</guid>
      <description>*Be warned! This is just &amp;ldquo;thought-expirement&amp;rdquo; post. Nothing has been tried or tested.*
My problem I have multiple computers. Each system has a different OS (or version) and configuration. One has Ubuntu 14, the others have Ubuntu 16. Some have had their packages updated, some have been neglected. Some are using NVIDIA graphics, others onboard Intel graphics.
The context switching from machine-to-machine for simple tasks is mind numbing.
Is Qt Creator installed?</description>
    </item>
    
    <item>
      <title>Performance: C&#43;&#43;/CLI vs COM</title>
      <link>https://www.pknopf.com/post/2013-03-06-cpp-cli-vs-com/</link>
      <pubDate>Thu, 07 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://www.pknopf.com/post/2013-03-06-cpp-cli-vs-com/</guid>
      <description>In my current project, we are going to require a great deal of native code due to interation with drivers and hardware. The application is going to be based in .NET, at least the UI portion, but the heart has to live in native C++.
I began investigating different ways to interop with .NET and unmanaged code. There seems to be three approaches.
 PInvoke COM/COM+/Interop C++/CLI  I did not look into the PInvoke method because I know that it will not be suitable for my needs.</description>
    </item>
    
  </channel>
</rss>