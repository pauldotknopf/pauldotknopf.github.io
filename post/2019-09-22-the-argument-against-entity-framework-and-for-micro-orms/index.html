<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The argument against Entity Framework, and for micro-ORMs. - Paul Knopf</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="/dist/styles.css" rel="stylesheet" type="text/css"/>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112478642-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-112478642-1');
  </script>
</head>
<body>
<header class="bg-light mb-3">
  <div class="navbar navbar-expand">
    <div class="container">
      <a href="/" class="navbar-brand d-flex">
        <strong>paul knopf</strong>
      </a>
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="/archive">archive</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">about</a>
        </li>
      </ul>
    </div>
  </div>
</header>
<main>
  
<div class="container">
    <div class="post">
        <h1 class="title">
            The argument against Entity Framework, and for micro-ORMs.
        </h1>
        <p class="submitted">
            posted on Sep 22, 2019
        </p>
        <div class="content">
            <h1 id="preface">Preface</h1>
<p>I've worked with Entity Framework (since the .NET 3.5 days, both code-first and database-first) as well as the latest .NET Core version. It was my preferred solution for a while and I've gotten pretty good with it. Looking back, I regret having to learn the hard way that EF is very taxing and it just isn't a good choice for most solutions.</p>
<p>There are many ORMs in the .NET world, but I think my point could be made when picking one of each a fully-fledged ORM, and a micro ORM.</p>
<ul>
<li>Full ORM - <a href="https://github.com/aspnet/EntityFrameworkCore">Entity Framework Core</a> - Chosen because it is the unofficial official version for .NET. It is front-and-center in most of the &quot;Getting Started&quot; docs and is what most junior devs will choose when beginning their journey into .NET.</li>
<li>Micro ORM - <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">ServiceStack.OrmLite</a> - For the sake of argument, I could easily have chosen other solutions, such as Dapper or PetaPoco, but I'm a fan of the API/features that ServiceStack.OrmLite provides. <em><strong>NOTE</strong>: OrmLite is free for open-source, but paid for closed-source.</em></li>
</ul>
<h1 id="surface-areaexposure">Surface area/exposure</h1>
<p>As with picking any dependency on your project, you must step back and take a 20,000-foot view of things to determine its impact on your solution. One way to do this is to consider the size of the dependency via the lines-of-code.</p>
<p>Using <code>cloc</code>, here is the overview of the size of each codebase.</p>
<div class="featured-image"><p><img src="/ef-vs-ss.jpg" alt="Entity Framework vs ServiceStack.OrmLite lines of code" /></p>
</div>
<p>Purely considering lines-of-code can be a fool's errand, but there is more to the story here. As the saying goes &quot;more money, more problems&quot;, right? As you increase your surface area (including your dependency graph), you increase your chances of running into bugs/issues. As you sit on top of more layers of abstraction and indirection, the problems that you begin to run into begin to get more cryptic and harder to isolate/fix.</p>
<p>You can get a sense of this by spending a few minutes on the issue pages for each ORM (<a href="https://forums.servicestack.net/c/ormlite">here</a> and <a href="https://github.com/aspnet/EntityFrameworkCore/issues?q=label%3Atype-bug+">here</a>). You'll find that the issues in OrmLite are generally about the problem-domain (getting data in-and-out of the database) or the underlying ADO provider, whereas the issues in EF generally involve the layers/types that are involved in the abstractions.</p>
<p>When it comes to the scope of your dependency and the exposure it brings to your project, I wouldn't take this point lightly. It is often overlooked, and when it does eventually tax your solution, it can go unnoticed/unrealized.</p>
<p>You can't escape the issues of just &quot;getting data in and out&quot; and the underlying database. However, there is a huge swath of issues that can be completely avoided by just choosing not to expose yourself. Smaller targets are harder to hit. Keep your dependencies small.</p>
<h1 id="bare-metal">Bare metal</h1>
<p>Micro ORMS are usually just extensions on top of raw ADO types (<code>IDbCommand</code>, <code>IDbConnection</code>, etc) and OrmLite is no exception. These extensions usually go only so far as to prevent the user from having to manually manage SQL strings, which is an obvious maintenance nightmare.</p>
<p>At this point of abstraction, no real complaints can be made. You get fully type-checked access to your underlying database, with a 1-to-1 relationship between your types and the data they represent. Your data types (POCOs) are expressed clearly. No magic. No voodoo. No &quot;secret&quot; tables for mapping many-to-many relationships. No complex graph management. No virtual proxies and lazy collections. No navigation properties leaked. These things usually end up just adding friction to your project, caking on additional features that silently tax you.</p>
<p>If exceptions happen when using OrmLite (or micro ORMs), they are usually a result of the underlying ADO provider, key constraints, etc. It's better to be closer to the metal when an issue arises because the cause/fix is usually more clear.</p>
<p>A common misconception is that &quot;because you're bare metal, you need more boilerplate!&quot; This just isn't true. I mean, in the case of working with HTTP over a raw TCP connection, of course. You'd want a higher-level abstraction. But this just isn't the case with OrmLite (or Micro ORMs in general). I'd wager that I'd get by with fewer lines of code when using OrmLite over EF.</p>
<p>Let's say you have a business requirement of storing/retrieving data. You've ruled out the need for non-conventional databases (graph, Cassandra, etc) and have decided that a relational database will work. The following code illustrates the <em>bare minimum needed</em> to tackle your problem, using OrmLite.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
    {
        [<span class="hljs-meta">AutoIncrement</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] _</span>)</span>
    {
        <span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteDialect.Provider);

        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> db = factory.OpenDbConnection())
        {
            db.CreateTable&lt;Person&gt;();

            <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person { Name = <span class="hljs-string">"Paul"</span> };
            <span class="hljs-keyword">var</span> personId = db.Save(person); <span class="hljs-comment">// Id is also auto set.</span>

            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> trans = db.OpenTransaction(IsolationLevel.ReadCommitted))
            { 
                person = db.Single(db.From&lt;Person&gt;().Where(x =&gt; x.Name == <span class="hljs-string">"Paul"</span>));
                person = db.SingleById&lt;Person&gt;(personId);

                person.Name = <span class="hljs-string">"Another name"</span>;

                db.Save(person);

                trans.Commit();
            }
        }
    }
}</code></pre>
<p>Any business requirement can be achieved with the above code. There is little in the way to prevent you from defining your solution/architecture how you'd like. OrmLite (micro ORMs) focus on exactly what is needed to solve your problem. Nothing more, nothing less. This brings me to my next point.</p>
<p>Heavy ORMs impose artificial abstractions that force you into a unique style of development that's introducing a further disconnect and layer of indirection between your code and your database, requiring the usage the usage of augmented and proxied EF-specific models. Using this abstraction isn't going to make you a better OOP of FP programmer or make you more knowledable about SQL or any RDBMS-specific features.</p>
<p>Sitting on EF's layers limits your ability to clearly perdict the behavior and functionality of each query, instead relying on EF-specific behavior. This makes it harder to reason about your code as you'll need to keep a hidden context of the incidental complexity in EF's behavior when reviewing code. You'd have to know exactly EF does, when it does it and why it does it when diagnosting unwanted behavior like unintended data access.</p>
<h1 id="missing-features">Missing features</h1>
<p>I believe I've set a high bar up until this point when it comes to choosing EF over OrmLite, but this doesn't factor the additional features that developers have come to love with EF.</p>
<ul>
<li>Migrations</li>
<li>Change tracking</li>
<li>Unit of work</li>
<li>Lazy collections</li>
<li>Navigation properties (joins and projections)</li>
<li>Result caching</li>
<li>Graph persistence</li>
<li>...the list goes on</li>
</ul>
<p>In my opinion, each of these features is unlikely to address a business concern directly. However, they are still typically highly valued by developers for various reasons.</p>
<p>These features must each be carefully considered. Even if you won't use/benefit from a feature, there is still a cost with having it exist at all. They typically only exist in heavy ORMs (EF) found in enterprise languages (Java/.NET).</p>
<p>I'd prefer to code againt clean APIs that lerverage the DB's underlying functionality and features.</p>
<p>With that said, let me try to address a few of these features.</p>
<h2 id="migrations">Migrations</h2>
<p>Migrations are a requirement of just about every solution. A few things to consider.</p>
<p>First, just because <em>you</em> didn't write the code, doesn't mean <em>someone</em> didn't write the code. Choosing a batteries-included approach doesn't make your solution any simpler. You can put the engine under the hood, or in the trunk, but it will still break down.</p>
<p>Secondly, choosing a batteries-included approach for a one-size-fits-all solution often means that there are additional edge cases for use-cases that just don't apply to you. This may seem irrelevant, but even if you are using 20% of the feature, that doesn't mean you aren't sitting the abstractions needed specifically needed for the other 80% you don't need.</p>
<p>Lastly, what happens when something goes wrong? Things are a lot easier to debug/fix when you own the solution and there isn't any white noise. What happens when you run into an issue like <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12911">this</a>? What about the time spent debugging? Or fixing a database that the migration failed on? At that point, you've already spent more time using a feature that you didn't implement than it would have taken to just implement migrations yourself.</p>
<p>Seriously, write your own migration layer. I wrote this in 3 minutes.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>;
        
        <span class="hljs-keyword">int</span> Version { <span class="hljs-keyword">get</span>; }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Migrator</span>
    {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> OrmLiteConnectionFactory _connectionFactory;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IList&lt;IMigration&gt; _migrations;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Migrator</span>(<span class="hljs-params">OrmLiteConnectionFactory connectionFactory, IList&lt;IMigration&gt; migrations</span>)</span>
        {
            _connectionFactory = connectionFactory;
            _migrations = migrations;
        }
        
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Migrate</span>(<span class="hljs-params"></span>)</span>
        {
            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> connection = _connectionFactory.OpenDbConnection())
            {
                connection.CreateTableIfNotExists&lt;Migration&gt;();

                <span class="hljs-keyword">var</span> installedMigrations = connection.Select&lt;Migration&gt;();

                <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> transaction = connection.BeginTransaction())
                {
                    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> migration <span class="hljs-keyword">in</span> _migrations.OrderBy(x =&gt; x.Version))
                    {
                        <span class="hljs-keyword">if</span> (installedMigrations.Any(x =&gt; x.Version == migration.Version))
                        {
                            <span class="hljs-comment">// Already done!</span>
                            <span class="hljs-keyword">continue</span>;
                        }
                        
                        migration.Run(connection);

                        connection.Insert(<span class="hljs-keyword">new</span> Migration
                            {Version = migration.Version, AppliedOn = DateTimeOffset.UtcNow});
                    }
                    
                    transaction.Commit();
                }
            }
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Migration</span>
        {
            [<span class="hljs-meta">AutoIncrement</span>]
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
            
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
            
            <span class="hljs-keyword">public</span> DateTimeOffset AppliedOn { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMigration1</span> : <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>
        {
            <span class="hljs-comment">// Raw and auditable SQL.</span>
            <span class="hljs-comment">// Create tables, add/drop columns, etc.</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version =&gt; <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMigration2</span> : <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>
        {
            <span class="hljs-comment">// Raw and auditable SQL.</span>
            <span class="hljs-comment">// Create tables, add/drop columns, etc.</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version =&gt; <span class="hljs-number">2</span>;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] _</span>)</span>
    {
        <span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteDialect.Provider);

       <span class="hljs-keyword">var</span> migrator = <span class="hljs-keyword">new</span> Migrator(factory, <span class="hljs-keyword">new</span> List&lt;IMigration&gt;
       {
           <span class="hljs-keyword">new</span> TestMigration1(),
           <span class="hljs-keyword">new</span> TestMigration2()
       });

       migrator.Migrate();
    }
}</code></pre>
<p>With less than 100 lines of code, you now have a solution that will have near-zero issues. And if there happens to be an issue, there is a good chance that any developer could fix it within minutes. There is no learning curve. No documentation to read. No CLIs to invoke. No hidden tax bill that will paid in the future.</p>
<h2 id="change-tracking">Change tracking</h2>
<blockquote>
<p><a href="https://twitter.com/ardave2002/status/1175119821261819905?s=20">@ardave2002</a>: I find having a giant ball of mutable state with change detection via virtual proxy that spans my application from one edge to the other to provide huge benefits to my ability to reason about code &lt;/s&gt;</p>
</blockquote>
<p>In my opinion, this feature is just annoying. There is a performance overhead that you introduce when using this feature. This causes you to leak concerns into your application layer, adding <code>AsNoTracking()</code> on all of your read-only queries. Also, having ambient state in your application is generally a bad idea. There are risks associated with having the semantics of <code>SaveChanges()</code> differ depending upon factors that are outside scope. It makes things very difficult to reason with at first glance.</p>
<h2 id="unit-of-work">Unit of work</h2>
<p>I have a hard time discussing this feature because people sometimes conflate this pattern with simple transactions, which exist in raw ADO. You will only have issues if you intend to use <code>TransactionScope</code> from EF, which is a little more than a simple transaction. If you don't intend on using this class, then this isn't a missing feature when choosing OrmLite over EF.</p>
<p>But if you need <code>TransactionScope</code>-like behavior, there are multiple ways in which this could be done. First, you could invert the creation of these objects so that implicitly shared/scoped instances can be used for every request. I've also used <code>AsyncLocal</code> successfully to use cached instances of <code>IDbConnection</code> and <code>IDbTransaction</code> for every nested method call. This is something that could be hand-rolled with minimal lines of code, similarly to the migration approach above.</p>
<p>But in the end, this only matters if you intend to use <code>TransactionScope</code>. Otherwise, this isn't a feature you're missing.</p>
<h2 id="lazy-collections">Lazy collections</h2>
<p>This is a feature that can seem appealing at first but can be very problematic. Do you want database queries to happen implicitly in your views? This is compounded when you are enumerating a collection of objects that have nested lazy properties, causing an additional database query for each for loop.</p>
<p>This is just a really bad idea. Define your query model upfront and fully load it to avoid unintended side effects that only show themselves when unbounded collections inevitably grow.</p>
<h1 id="misc">Misc</h1>
<p>What happens when things just are performant with EF? It's great that it allows you to analyze the SQL being executed, but at that point, you are still at the mercy of the underlying SQL generation. You may decide to jump out of EF in these cases and just execute raw SQL, but why even subject yourself to this?</p>
<p>I also don't like hearing the caveats of &quot;if you know how to use it&quot; or &quot;when used right&quot; when describing features of EF. I'm uncomfortable with the idea of playing hot potato with loaded guns, hoping every person catches the gun <em>just right</em>. Not everyone is as knowledgeable as you. Code reviews are a good thing, but <em>depending</em> upon them isn't a good idea. Things get past code reviews. All developers suck, including me and you. Why even risk it?</p>
<h1 id="final-words">Final words</h1>
<p>An ORM should only serve to give you a type-safe approach to writing SQL. Anything else is a tax that gets compounded as your project evolves.</p>
<p>You could use EF and everything turns out just fine, but the standard deviation between success and failure is wide. When you choose a micro ORM, that standard deviation is much smaller.</p>
<p>Quite frankly, you'd be hard-pressed to ever find a business requirement that <em>only</em> EF could solve. The features that EF provides and OrmLite doesn't are welcomed by developers as being time-saving nice-to-haves. However, when you factor in the taxing nature of using such a large framework like EF, you'll spend more time using it than if you were to just keep things minimal and bare-metal. This is especially true for larger projects involving people with ranging experiences.</p>
<p>If you'd like to add anything, please comment. I love the discussion.</p>
<p><strong>Update</strong>: I created <a href="https://github.com/pauldotknopf/sharp-data-access">SharpDataAccess</a>. It is a thin layer that sits on top of ServiceStack.OrmLite that adds migrations and ambient connections/transactions.</p>

        </div>
            <hr />
            <h3>Comments</h3>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Lux44" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/8456057?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Lux44" target="_blank" class="user">Lux44</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-533975148" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T06:34:38.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Thank you for not advocating building queries from strings :).</p>
<p>Change tracking downside of Entity Framework could have an easy enough workaround: use new DBContext for applying changes, then effects are more obvious.</p>
<p>What doesn't have an easy workaround: startup time of Entity Framework, which is quite noticeable in  desktop apps.</p>
<p>Right now is not really a great time to look at EF bug list, or jump into EF, for that matter. The query translator got rewritten, but hasn't really stabilized, as the issue list rightfully indicates. Their test coverage for new/rewritten parts is also not great. "Please try again with nightly builds" has been the standard response for over a month now. Let's hope by the time 3.1 releases in November things have stabilized.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/lufthavn" target="_blank">
                                <img src="https://avatars2.githubusercontent.com/u/7838029?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/lufthavn" target="_blank" class="user">lufthavn</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-533988580" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T07:30:46.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>I stumbled into this article on reddit, and really liked it. I agree with a lot of what you're saying. <g-emoji class="g-emoji" alias="blush" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png">üòä</g-emoji><br>
However, the quote you've included in the "Change Tracking" paragraph feels like a straw man. I agree that it can be dangerous to throw around change tracking entities to every corner of your system, and thus lose sight of what actually happening in your system, but I feel like most people know this shouldn't be done, and that if you have this problem in your code base, it might be a code smell.<br>
Currently I like to implement a command-handler approach in my system, where a command corresponds to a particular business concern, and has only one handler, where I centralize the preparation and execution of my business logic.<br>
I agree that the change tracking gets in the way when all you need is to load read-only data for display. Not only that but if you're eager loading, and have only a couple of nested collections in your entities, the amount of data EF is querying the database for can get huge. We recently had to debug this problem where I work. A request for ~1000 entities could result in result sets of well over 100,000 lines. Surely this could be optimized in EF, but when I encounter something like this, I like to take a step back and evaluate the tool we're using.<br>
If you're querying read-only data from the database, what exactly do you need an ORM for? I'd advocate for introducing a micro-ORM (Dapper is my current favorite, but I might check out ServiceStack.OrmLite soon <g-emoji class="g-emoji" alias="wink" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png">üòâ</g-emoji>). Nobody says you can't use more than one data-access library in your solution.<br>
This approach of using full-fledged ORMs to retrieve and save business entities in your command handlers, and using bare metal ADO.net or a micro-ORM to very efficiently query for read-only data goes very well with the architectural pattern of CQRS, and is why I recommend it a lot to developers who are dealing with large systems and complex domains.</p>
<p>Anyway, the blog post was great, and I generally I agree with you. <g-emoji class="g-emoji" alias="blush" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png">üòä</g-emoji> Just don't write ORMs off right of the bat, and consider them as a tool as you would any other dependency in your system.<br>
Hope this brain dump makes to sense anybody. <g-emoji class="g-emoji" alias="sweat_smile" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png">üòÖ</g-emoji></p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/sharpninja" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/16146732?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/sharpninja" target="_blank" class="user">sharpninja</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534077664" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T12:30:08.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>This blog post is good up to a certain level of application complexity.  Most large enterprise projects are going to be dealing with data sets with millions of rows of data, with billions of relational outcomes.  Advocating eager loading in such a scenario is non-sense.  EF allows you to cherry pick relationships to eager load when using lazy loading by default.  If you are using a webserver and constantly eager loading large graphs then you are placing a huge burden on the server to load data that gets dumped in the garbage when the controller returns.  If it's a desktop app, you may get away with it for a while, but eventually your app will be holding a couple of gigs of data in RAM and user experience will suffer.  On mobile, you should be just as strict with memory usage as on a REST server.</p>
<p>EF was designed to work in all these scenarios and when used correctly, does so admirably.  Enterprise code bases need consistency and reliability as their top concerns for maintainability.  Designing a system under the assumption that only you or someone of your skill level will be maintaining code is both arrogant and dangerous.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534173305" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:18:12.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>There's other options for ORMs.</p>
<p>For example, Tortuga Chain (which I work on) using database reflection. Rather than just assuming the class exactly matches the table or doing everything using SQL string literals, it compares the table and class definitions at runtime. This dramatically reduces the boilerplate, especially when you don't want every column.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534173775" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:19:30.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Another is SQL Alchemy which allows you to build complex SQL expressions using an object model. Unfortunately it is Python only at this time.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534178201" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:30:47.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Regarding boilerplate, consider this line:</p>
<p>Consider this line:</p>
<pre><code>dataSource.Update("dbo.Person", new { ID = personId, Name = "Another Name"}).Exceute();
</code></pre>
<p>Why can't all ORMs do this? Why do they usually require manually dealing with connections/contexts and an extra round trip to the database just to perform a simple update?</p>
<p>In my opinion, the only time I should see a <code>using</code> statement in my DB code is when I actually need a transaction. And that should only be needed if I'm updating multiple records.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534266575" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T20:17:52.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>This is the same Update query in OrmLite:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">db</span>.<span class="pl-en">UpdateOnly</span>(() <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">Person</span> { <span class="pl-smi">Id</span> <span class="pl-k">=</span> <span class="pl-smi">personId</span>, <span class="pl-smi">Name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> });</pre></div>
<p>Which if you prefer you could also update from an anonymous object or untyped Dictionary, e.g:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">db</span>.<span class="pl-en">Update</span>&lt;<span class="pl-en">Person</span>&gt;(<span class="pl-k">new</span>  { <span class="pl-smi">Id</span> <span class="pl-k">=</span> <span class="pl-smi">personId</span>, <span class="pl-smi">Name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> });

<span class="pl-smi">db</span>.<span class="pl-en">Update</span>&lt;<span class="pl-en">Person</span>&gt;(<span class="pl-k">new</span> <span class="pl-en">Dictionary</span>&lt;<span class="pl-k">string</span>,<span class="pl-k">object</span>&gt; { 
    [<span class="pl-s"><span class="pl-pds">"</span>Id<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-smi">personId</span>, 
    [<span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> 
});</pre></div>
<p>Other <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#update">Update Examples in OrmLite</a>.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
            <p class="text-center">
                <a class="btn btn-primary btn-light btn-lg" target="_blank" href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#new_comment_field"><i class="fab fa-github"></i> Join the discussion at GitHub</a>
            </p>
    </div>
</div>
</main>
<footer class="bg-light py-3 mt-5 text-muted text-center">
  <a href="https://github.com/pauldotknopf/pauldotknopf.github.io"><i class="fab fa-github"></i> source</a>
</footer>
<script src="/dist/scripts.js"></script>
</body>
</html>
