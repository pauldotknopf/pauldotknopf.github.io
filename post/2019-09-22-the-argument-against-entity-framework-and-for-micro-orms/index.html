<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The argument against Entity Framework, and for micro-ORMs. - Paul Knopf</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="/dist/styles.css" rel="stylesheet" type="text/css"/>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112478642-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-112478642-1');
  </script>
</head>
<body>
<header class="bg-light mb-5">
  <div class="navbar navbar-expand">
    <div class="container">
      <a href="/" class="navbar-brand d-flex">
        <strong>paul knopf</strong>
      </a>
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="/archive">archive</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">about</a>
        </li>
      </ul>
    </div>
  </div>
</header>
<main>
  
<div class="container">
    <div class="post">
        <h1 class="title">
            The argument against Entity Framework, and for micro-ORMs.
        </h1>
        <p class="submitted">
            posted on Sep 22, 2019
        </p>
        <div class="content">
            <h1 id="preface">Preface</h1>
<p>I've worked with Entity Framework (since the .NET 3.5 days, both code-first and database-first) as well as the latest .NET Core version. It was my preferred solution for a while and I've gotten pretty good with it. Looking back, I regret having to learn the hard way that EF is very taxing and it just isn't a good choice for most solutions.</p>
<p>There are many ORMs in the .NET world, but I think my point could be made when picking one of each a fully-fledged ORM, and a micro ORM.</p>
<ul>
<li>Full ORM - <a href="https://github.com/aspnet/EntityFrameworkCore">Entity Framework Core</a> - Chosen because it is the unofficial official version for .NET. It is front-and-center in most of the &quot;Getting Started&quot; docs and is what most junior devs will choose when beginning their journey into .NET.</li>
<li>Micro ORM - <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">ServiceStack.OrmLite</a> - For the sake of argument, I could easily have chosen other solutions, such as Dapper or PetaPoco, but I'm a fan of the API/features that ServiceStack.OrmLite provides. <em><strong>NOTE</strong>: OrmLite is free for open-source, but paid for closed-source.</em></li>
</ul>
<h1 id="surface-areaexposure">Surface area/exposure</h1>
<p>As with picking any dependency on your project, you must step back and take a 20,000-foot view of things to determine its impact on your solution. One way to do this is to consider the size of the dependency via the lines-of-code.</p>
<p>Using <code>cloc</code>, here is the overview of the size of each codebase.</p>
<div class="featured-image"><p><img src="/ef-vs-ss.jpg" alt="Entity Framework vs ServiceStack.OrmLite lines of code" /></p>
</div>
<p>Purely considering lines-of-code can be a fool's errand, but there is more to the story here. As the saying goes &quot;more money, more problems&quot;, right? As you increase your surface area (including your dependency graph), you increase your chances of running into bugs/issues. As you sit on top of more layers of abstraction and indirection, the problems that you begin to run into begin to get more cryptic and harder to isolate/fix.</p>
<p>You can get a sense of this by spending a few minutes on the issue pages for each ORM (<a href="https://forums.servicestack.net/c/ormlite">here</a> and <a href="https://github.com/aspnet/EntityFrameworkCore/issues?q=label%3Atype-bug+">here</a>). You'll find that the issues in OrmLite are generally about the problem-domain (getting data in-and-out of the database) or the underlying ADO provider, whereas the issues in EF generally involve the layers/types that are involved in the abstractions.</p>
<p>When it comes to the scope of your dependency and the exposure it brings to your project, I wouldn't take this point lightly. It is often overlooked, and when it does eventually tax your solution, it can go unnoticed/unrealized.</p>
<p>You can't escape the issues of just &quot;getting data in and out&quot; and the underlying database. However, there is a huge swath of issues that can be completely avoided by just choosing not to expose yourself. Smaller targets are harder to hit. Keep your dependencies small.</p>
<h1 id="bare-metal">Bare metal</h1>
<p>Micro ORMS are usually just extensions on top of raw ADO types (<code>IDbCommand</code>, <code>IDbConnection</code>, etc) and OrmLite is no exception. These extensions usually go only so far as to prevent the user from having to manually manage SQL strings, which is an obvious maintenance nightmare.</p>
<p>At this point of abstraction, no real complaints can be made. You get fully type-checked access to your underlying database, with a 1-to-1 relationship between your types and the data they represent. Your data types (POCOs) are expressed clearly. No magic. No voodoo. No &quot;secret&quot; tables for mapping many-to-many relationships. No complex graph management. No virtual proxies and lazy collections. No navigation properties leaked. These things usually end up just adding friction to your project, caking on additional features that silently tax you.</p>
<p>If exceptions happen when using OrmLite (or micro ORMs), they are usually a result of the underlying ADO provider, key constraints, etc. It's better to be closer to the metal when an issue arises because the cause/fix is usually more clear.</p>
<p>A common misconception is that &quot;because you're bare metal, you need more boilerplate!&quot; This just isn't true. I mean, in the case of working with HTTP over a raw TCP connection, of course. You'd want a higher-level abstraction. But this just isn't the case with OrmLite (or Micro ORMs in general). I'd wager that I'd get by with fewer lines of code when using OrmLite over EF.</p>
<p>Let's say you have a business requirement of storing/retrieving data. You've ruled out the need for non-conventional databases (graph, Cassandra, etc) and have decided that a relational database will work. The following code illustrates the <em>bare minimum needed</em> to tackle your problem, using OrmLite.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
    {
        [<span class="hljs-meta">AutoIncrement</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] _</span>)</span>
    {
        <span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteDialect.Provider);

        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> db = factory.OpenDbConnection())
        {
            db.CreateTable&lt;Person&gt;();

            <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person { Name = <span class="hljs-string">"Paul"</span> };
            <span class="hljs-keyword">var</span> personId = db.Save(person); <span class="hljs-comment">// Id is also auto set.</span>

            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> trans = db.OpenTransaction(IsolationLevel.ReadCommitted))
            { 
                person = db.Single(db.From&lt;Person&gt;().Where(x =&gt; x.Name == <span class="hljs-string">"Paul"</span>));
                person = db.SingleById&lt;Person&gt;(personId);

                person.Name = <span class="hljs-string">"Another name"</span>;

                db.Save(person);

                trans.Commit();
            }
        }
    }
}</code></pre>
<p>Any business requirement can be achieved with the above code. There is little in the way to prevent you from defining your solution/architecture how you'd like. OrmLite (micro ORMs) focus on exactly what is needed to solve your problem. Nothing more, nothing less. This brings me to my next point.</p>
<p>Heavy ORMs impose artificial abstractions that force you into a unique style of development that's introducing a further disconnect and layer of indirection between your code and your database, requiring the usage the usage of augmented and proxied EF-specific models. Using this abstraction isn't going to make you a better OOP of FP programmer or make you more knowledable about SQL or any RDBMS-specific features.</p>
<p>Sitting on EF's layers limits your ability to clearly perdict the behavior and functionality of each query, instead relying on EF-specific behavior. This makes it harder to reason about your code as you'll need to keep a hidden context of the incidental complexity in EF's behavior when reviewing code. You'd have to know exactly EF does, when it does it and why it does it when diagnosting unwanted behavior like unintended data access.</p>
<h1 id="missing-features">Missing features</h1>
<p>I believe I've set a high bar up until this point when it comes to choosing EF over OrmLite, but this doesn't factor the additional features that developers have come to love with EF.</p>
<ul>
<li>Migrations</li>
<li>Change tracking</li>
<li>Unit of work</li>
<li>Lazy collections</li>
<li>Navigation properties (joins and projections)</li>
<li>Result caching</li>
<li>Graph persistence</li>
<li>...the list goes on</li>
</ul>
<p>In my opinion, each of these features is unlikely to address a business concern directly. However, they are still typically highly valued by developers for various reasons.</p>
<p>These features must each be carefully considered. Even if you won't use/benefit from a feature, there is still a cost with having it exist at all. They typically only exist in heavy ORMs (EF) found in enterprise languages (Java/.NET).</p>
<p>I'd prefer to code againt clean APIs that lerverage the DB's underlying functionality and features.</p>
<p>With that said, let me try to address a few of these features.</p>
<h2 id="migrations">Migrations</h2>
<p>Migrations are a requirement of just about every solution. A few things to consider.</p>
<p>First, just because <em>you</em> didn't write the code, doesn't mean <em>someone</em> didn't write the code. Choosing a batteries-included approach doesn't make your solution any simpler. You can put the engine under the hood, or in the trunk, but it will still break down.</p>
<p>Secondly, choosing a batteries-included approach for a one-size-fits-all solution often means that there are additional edge cases for use-cases that just don't apply to you. This may seem irrelevant, but even if you are using 20% of the feature, that doesn't mean you aren't sitting the abstractions needed specifically needed for the other 80% you don't need.</p>
<p>Lastly, what happens when something goes wrong? Things are a lot easier to debug/fix when you own the solution and there isn't any white noise. What happens when you run into an issue like <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12911">this</a>? What about the time spent debugging? Or fixing a database that the migration failed on? At that point, you've already spent more time using a feature that you didn't implement than it would have taken to just implement migrations yourself.</p>
<p>Seriously, write your own migration layer. I wrote this in 3 minutes.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>;
        
        <span class="hljs-keyword">int</span> Version { <span class="hljs-keyword">get</span>; }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Migrator</span>
    {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> OrmLiteConnectionFactory _connectionFactory;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IList&lt;IMigration&gt; _migrations;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Migrator</span>(<span class="hljs-params">OrmLiteConnectionFactory connectionFactory, IList&lt;IMigration&gt; migrations</span>)</span>
        {
            _connectionFactory = connectionFactory;
            _migrations = migrations;
        }
        
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Migrate</span>(<span class="hljs-params"></span>)</span>
        {
            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> connection = _connectionFactory.OpenDbConnection())
            {
                connection.CreateTableIfNotExists&lt;Migration&gt;();

                <span class="hljs-keyword">var</span> installedMigrations = connection.Select&lt;Migration&gt;();

                <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> transaction = connection.BeginTransaction())
                {
                    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> migration <span class="hljs-keyword">in</span> _migrations.OrderBy(x =&gt; x.Version))
                    {
                        <span class="hljs-keyword">if</span> (installedMigrations.Any(x =&gt; x.Version == migration.Version))
                        {
                            <span class="hljs-comment">// Already done!</span>
                            <span class="hljs-keyword">continue</span>;
                        }
                        
                        migration.Run(connection);

                        connection.Insert(<span class="hljs-keyword">new</span> Migration
                            {Version = migration.Version, AppliedOn = DateTimeOffset.UtcNow});
                    }
                    
                    transaction.Commit();
                }
            }
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Migration</span>
        {
            [<span class="hljs-meta">AutoIncrement</span>]
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
            
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
            
            <span class="hljs-keyword">public</span> DateTimeOffset AppliedOn { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMigration1</span> : <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>
        {
            <span class="hljs-comment">// Raw and auditable SQL.</span>
            <span class="hljs-comment">// Create tables, add/drop columns, etc.</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version =&gt; <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMigration2</span> : <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>
        {
            <span class="hljs-comment">// Raw and auditable SQL.</span>
            <span class="hljs-comment">// Create tables, add/drop columns, etc.</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version =&gt; <span class="hljs-number">2</span>;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] _</span>)</span>
    {
        <span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteDialect.Provider);

       <span class="hljs-keyword">var</span> migrator = <span class="hljs-keyword">new</span> Migrator(factory, <span class="hljs-keyword">new</span> List&lt;IMigration&gt;
       {
           <span class="hljs-keyword">new</span> TestMigration1(),
           <span class="hljs-keyword">new</span> TestMigration2()
       });

       migrator.Migrate();
    }
}</code></pre>
<p>With less than 100 lines of code, you now have a solution that will have near-zero issues. And if there happens to be an issue, there is a good chance that any developer could fix it within minutes. There is no learning curve. No documentation to read. No CLIs to invoke. No hidden tax bill that will paid in the future.</p>
<h2 id="change-tracking">Change tracking</h2>
<blockquote>
<p><a href="https://twitter.com/ardave2002/status/1175119821261819905?s=20">@ardave2002</a>: I find having a giant ball of mutable state with change detection via virtual proxy that spans my application from one edge to the other to provide huge benefits to my ability to reason about code &lt;/s&gt;</p>
</blockquote>
<p>In my opinion, this feature is just annoying. There is a performance overhead that you introduce when using this feature. This causes you to leak concerns into your application layer, adding <code>AsNoTracking()</code> on all of your read-only queries. Also, having ambient state in your application is generally a bad idea. There are risks associated with having the semantics of <code>SaveChanges()</code> differ depending upon factors that are outside scope. It makes things very difficult to reason with at first glance.</p>
<h2 id="unit-of-work">Unit of work</h2>
<p>I have a hard time discussing this feature because people sometimes conflate this pattern with simple transactions, which exist in raw ADO. You will only have issues if you intend to use <code>TransactionScope</code> from EF, which is a little more than a simple transaction. If you don't intend on using this class, then this isn't a missing feature when choosing OrmLite over EF.</p>
<p>But if you need <code>TransactionScope</code>-like behavior, there are multiple ways in which this could be done. First, you could invert the creation of these objects so that implicitly shared/scoped instances can be used for every request. I've also used <code>AsyncLocal</code> successfully to use cached instances of <code>IDbConnection</code> and <code>IDbTransaction</code> for every nested method call. This is something that could be hand-rolled with minimal lines of code, similarly to the migration approach above.</p>
<p>But in the end, this only matters if you intend to use <code>TransactionScope</code>. Otherwise, this isn't a feature you're missing.</p>
<h2 id="lazy-collections">Lazy collections</h2>
<p>This is a feature that can seem appealing at first but can be very problematic. Do you want database queries to happen implicitly in your views? This is compounded when you are enumerating a collection of objects that have nested lazy properties, causing an additional database query for each for loop.</p>
<p>This is just a really bad idea. Define your query model upfront and fully load it to avoid unintended side effects that only show themselves when unbounded collections inevitably grow.</p>
<h1 id="misc">Misc</h1>
<p>What happens when things just are performant with EF? It's great that it allows you to analyze the SQL being executed, but at that point, you are still at the mercy of the underlying SQL generation. You may decide to jump out of EF in these cases and just execute raw SQL, but why even subject yourself to this?</p>
<p>I also don't like hearing the caveats of &quot;if you know how to use it&quot; or &quot;when used right&quot; when describing features of EF. I'm uncomfortable with the idea of playing hot potato with loaded guns, hoping every person catches the gun <em>just right</em>. Not everyone is as knowledgeable as you. Code reviews are a good thing, but <em>depending</em> upon them isn't a good idea. Things get past code reviews. All developers suck, including me and you. Why even risk it?</p>
<h1 id="final-words">Final words</h1>
<p>An ORM should only serve to give you a type-safe approach to writing SQL. Anything else is a tax that gets compounded as your project evolves.</p>
<p>You could use EF and everything turns out just fine, but the standard deviation between success and failure is wide. When you choose a micro ORM, that standard deviation is much smaller.</p>
<p>Quite frankly, you'd be hard-pressed to ever find a business requirement that <em>only</em> EF could solve. The features that EF provides and OrmLite doesn't are welcomed by developers as being time-saving nice-to-haves. However, when you factor in the taxing nature of using such a large framework like EF, you'll spend more time using it than if you were to just keep things minimal and bare-metal. This is especially true for larger projects involving people with ranging experiences.</p>
<p>If you'd like to add anything, please comment. I love the discussion.</p>
<p><strong>Update</strong>: I created <a href="https://github.com/pauldotknopf/sharp-data-access">SharpDataAccess</a>. It is a thin layer that sits on top of ServiceStack.OrmLite that adds migrations and ambient connections/transactions.</p>

        </div>
            <hr />
            <h3>Comments</h3>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Lux44" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/8456057?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Lux44" target="_blank" class="user">Lux44</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-533975148" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T06:34:38.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Thank you for not advocating building queries from strings :).</p>
<p>Change tracking downside of Entity Framework could have an easy enough workaround: use new DBContext for applying changes, then effects are more obvious.</p>
<p>What doesn't have an easy workaround: startup time of Entity Framework, which is quite noticeable in  desktop apps.</p>
<p>Right now is not really a great time to look at EF bug list, or jump into EF, for that matter. The query translator got rewritten, but hasn't really stabilized, as the issue list rightfully indicates. Their test coverage for new/rewritten parts is also not great. "Please try again with nightly builds" has been the standard response for over a month now. Let's hope by the time 3.1 releases in November things have stabilized.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/lufthavn" target="_blank">
                                <img src="https://avatars2.githubusercontent.com/u/7838029?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/lufthavn" target="_blank" class="user">lufthavn</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-533988580" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T07:30:46.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>I stumbled into this article on reddit, and really liked it. I agree with a lot of what you're saying. <g-emoji class="g-emoji" alias="blush" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png">üòä</g-emoji><br>
However, the quote you've included in the "Change Tracking" paragraph feels like a straw man. I agree that it can be dangerous to throw around change tracking entities to every corner of your system, and thus lose sight of what actually happening in your system, but I feel like most people know this shouldn't be done, and that if you have this problem in your code base, it might be a code smell.<br>
Currently I like to implement a command-handler approach in my system, where a command corresponds to a particular business concern, and has only one handler, where I centralize the preparation and execution of my business logic.<br>
I agree that the change tracking gets in the way when all you need is to load read-only data for display. Not only that but if you're eager loading, and have only a couple of nested collections in your entities, the amount of data EF is querying the database for can get huge. We recently had to debug this problem where I work. A request for ~1000 entities could result in result sets of well over 100,000 lines. Surely this could be optimized in EF, but when I encounter something like this, I like to take a step back and evaluate the tool we're using.<br>
If you're querying read-only data from the database, what exactly do you need an ORM for? I'd advocate for introducing a micro-ORM (Dapper is my current favorite, but I might check out ServiceStack.OrmLite soon <g-emoji class="g-emoji" alias="wink" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png">üòâ</g-emoji>). Nobody says you can't use more than one data-access library in your solution.<br>
This approach of using full-fledged ORMs to retrieve and save business entities in your command handlers, and using bare metal ADO.net or a micro-ORM to very efficiently query for read-only data goes very well with the architectural pattern of CQRS, and is why I recommend it a lot to developers who are dealing with large systems and complex domains.</p>
<p>Anyway, the blog post was great, and I generally I agree with you. <g-emoji class="g-emoji" alias="blush" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png">üòä</g-emoji> Just don't write ORMs off right of the bat, and consider them as a tool as you would any other dependency in your system.<br>
Hope this brain dump makes to sense anybody. <g-emoji class="g-emoji" alias="sweat_smile" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png">üòÖ</g-emoji></p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/sharpninja" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/16146732?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/sharpninja" target="_blank" class="user">sharpninja</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534077664" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T12:30:08.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>This blog post is good up to a certain level of application complexity.  Most large enterprise projects are going to be dealing with data sets with millions of rows of data, with billions of relational outcomes.  Advocating eager loading in such a scenario is non-sense.  EF allows you to cherry pick relationships to eager load when using lazy loading by default.  If you are using a webserver and constantly eager loading large graphs then you are placing a huge burden on the server to load data that gets dumped in the garbage when the controller returns.  If it's a desktop app, you may get away with it for a while, but eventually your app will be holding a couple of gigs of data in RAM and user experience will suffer.  On mobile, you should be just as strict with memory usage as on a REST server.</p>
<p>EF was designed to work in all these scenarios and when used correctly, does so admirably.  Enterprise code bases need consistency and reliability as their top concerns for maintainability.  Designing a system under the assumption that only you or someone of your skill level will be maintaining code is both arrogant and dangerous.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534173305" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:18:12.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>There's other options for ORMs.</p>
<p>For example, Tortuga Chain (which I work on) using database reflection. Rather than just assuming the class exactly matches the table or doing everything using SQL string literals, it compares the table and class definitions at runtime. This dramatically reduces the boilerplate, especially when you don't want every column.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534173775" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:19:30.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Another is SQL Alchemy which allows you to build complex SQL expressions using an object model. Unfortunately it is Python only at this time.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534178201" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:30:47.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Regarding boilerplate, consider this line:</p>
<p>Consider this line:</p>
<pre><code>dataSource.Update("dbo.Person", new { ID = personId, Name = "Another Name"}).Exceute();
</code></pre>
<p>Why can't all ORMs do this? Why do they usually require manually dealing with connections/contexts and an extra round trip to the database just to perform a simple update?</p>
<p>In my opinion, the only time I should see a <code>using</code> statement in my DB code is when I actually need a transaction. And that should only be needed if I'm updating multiple records.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534266575" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T20:17:52.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>This is the same Update query in OrmLite:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">db</span>.<span class="pl-en">UpdateOnly</span>(() <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">Person</span> { <span class="pl-smi">Id</span> <span class="pl-k">=</span> <span class="pl-smi">personId</span>, <span class="pl-smi">Name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> });</pre></div>
<p>Which if you prefer you could also update from an anonymous object or untyped Dictionary, e.g:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">db</span>.<span class="pl-en">Update</span>&lt;<span class="pl-en">Person</span>&gt;(<span class="pl-k">new</span>  { <span class="pl-smi">Id</span> <span class="pl-k">=</span> <span class="pl-smi">personId</span>, <span class="pl-smi">Name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> });

<span class="pl-smi">db</span>.<span class="pl-en">Update</span>&lt;<span class="pl-en">Person</span>&gt;(<span class="pl-k">new</span> <span class="pl-en">Dictionary</span>&lt;<span class="pl-k">string</span>,<span class="pl-k">object</span>&gt; { 
    [<span class="pl-s"><span class="pl-pds">"</span>Id<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-smi">personId</span>, 
    [<span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> 
});</pre></div>
<p>Other <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#update">Update Examples in OrmLite</a>.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 2
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598156324" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T12:21:18.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>Having read this .... many of the points here are exactly where i'm at right now ... the hidden technical debt, abstraction issues I can't solve, complexity with no explanation, poor performance in scenarios that often seem trivial on face value.</p>
<p>I'm currently looking in to an alternative to EF Core to resolve a ton of issues I have that the EF Core team seems to be either confused about, not interested in, or simply willing to pick at my description rather than focusing on the issue at hand.</p>
<p>The fact is, since EF6, each and every subsequent release has removed or broken functionality that my stack has depended on and i'm sick of swallowing that with the reasoning being "this is the cost of progress".</p>
<p>So here's where i'm at ...<br>
I'm trying to find an alternative that as this blog post states should not be an issue because "there shouldn't be a problem that EF solves that another framework couldn't also solve".</p>
<p>So here's my core functionality requirements from the EF functionality that I currently use ...</p>
<ul>
<li>Mapping LINQ to SQL</li>
<li>Mapping SQL query results to Entities</li>
<li>Managing / migrating the DB (ideally without having to manually crank out SQL myself)</li>
<li>Complex filtration when "nested questions" happen.</li>
</ul>
<p>That last point appears to be the sticking point for most "micro-ORMs" .. the "micro" prefix usually means like with say Dapper that it does the SQL query to Entity mapping but won't do the bit before that to get from the LINQ expression tree to SQL.</p>
<p>Assuming this ORM can handle that I'm looking for examples ofdoing things like applying set filters so I can achieve something like ...</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> <span class="pl-smi">results</span> <span class="pl-k">=</span> <span class="pl-smi">Db</span>.<span class="pl-en">GetAll</span>&lt;<span class="pl-en">BaseT</span>&gt;()
   .<span class="pl-en">Include</span>(<span class="pl-smi">t</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">t</span>.<span class="pl-smi">Property</span>)
       .<span class="pl-en">ThenInclude</span>(<span class="pl-smi">i</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">i</span>.<span class="pl-smi">SubProperty</span>)
   .<span class="pl-en">ToArray</span>();</pre></div>
<p>... key things to note here that EF solves that I can't seem to find a solution to in other ORM's the include, and then the sub include are both filtered by the relationship but also on filter conditions applied to the table regardless of context in which that table is questioned.</p>
<p>This seems to be a feature missing in all but EF.</p>
<p>Does this ORM support this scenario?</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598162844" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T12:38:44.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>OrmLite supports <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#reference-support-poco-style">"POCO References"</a> where it lets you load all nested references with its <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#querying-pocos-with-references">Load* APIs</a> whereas all OrmLite's other APIs wont load any nested references, so you can't pick and choose which references you want to load (i.e. without defining different classes with different references), but as all APIs returns POCOs you also have the option to <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#merge-disconnected-poco-result-sets">stitch &amp; merge multiple POCO resultsets together</a>.</p>
<p>Like all of OrmLite APIs they return "disconnected POCOs" so it's not possible to have hidden N+1 queries that could occur when traversing the result set. i.e. you get back your exact POCOs you've defined, not some proxy sub class with injected decorated behavior.</p>
<p>OrmLite also includes typed APIs for inspecting and <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">altering existing schemas</a>. Paul <a href="https://pknopf.com/post/2019-09-22-the-argument-against-entity-framework-and-for-micro-orms/#migrations" rel="nofollow">outlines a good migration solution</a> on his blog, there's also a few different migration solutions in this <a href="https://forums.servicestack.net/t/any-recommendations-for-maintaining-database-schemas/3304" rel="nofollow">Customer Forums Thread</a>.</p>
<p>I'd recommend reading the <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite docs on its home page</a> which documents its many features.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598318280" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T17:34:32.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>This requires you to know all the possible combinations of questions that you might want to ask the api up front or manually wiring up a second model so that the traversal is possible with sub queries.<br>
That's never a desired result when you have a db with potentially billions of rows to manage and you want a joned set of maybe 1,000 of them from the results of a single dynamically generated SQL query.</p>
<p>Consider putting an OrmLite managed DB behind an OData API where the questions are virtually limitless but every possible combination of scenarios has to be considered and handled.<br>
With EF this is trivial as I can tell EF that the Set has a filter and then any time EF sees any portion of a linq query hitting a given table it applies the filter then the requested query to the SQL query.</p>
<p>People often forget about the complexity that EF is solving stating that something is a "micro-ORM" instead of a "full ORM" is seemingly just like declaring "this solves half your issue, now go find something else that solves the other half, but it's fast ok".</p>
<p>I've not yet found anything that can match this type of EF solved scenario that didn't require a crap ton of "work arounds" or "patching stuff together" and it's the one thing that keeps my solutions sat on it ... which is frustrating because I both hate it and have to use it at the same time as there is seemingly no alternative.</p>
<p>Other things of note ...</p>
<ul>
<li>For some reason Code generation is seen as bad</li>
<li>Designer tooling focus is seen as bad</li>
</ul>
<p>... all features that I often use to solve dynamic scenarios that would otherwise be unsolvable or for situations like I don't want to sit around writing boiler plate stuff like the SQL statement for building a table when I have a class that exactly matches it's structure.</p>
<p>Also, the current version of EF core will never return "some proxy sub class with injected decorated behavior", as that functionality was ripped out as part of the rebuild when EF6 became EF Core 1.0.</p>
<p>My current entity model, has a DbContext as you might expect with entity sets, none of which I pull from the Db in such a manner that I use things like Lazy loading, or proxies, or in any way require the resulting entities to be "attached" to the context, this is basically the same setup as is explained here.</p>
<p>My ideal ORM would allow me to do something like ...</p>
<pre><code>using(var db = new factory.GetConnection("db name"))
{
       IQueryable&lt;T&gt; results = new Query&lt;T&gt;().Where(...).Select(...).Include(...).OrderBy();
}
</code></pre>
<p>... in this situation I would be constructing a simple ADO.Net connection to the Db and then telling the framework "build me a SQL query of Type T", large complex "models" seem to feel like overkill for me since the type metadata for the query you're building should tell you all you need to know.</p>
<p>I continue my composition on that to construct the full query, including notifying it (as per my previous comment) of what "sub sets" I want in the results, then performing a .ToArray()  .ToList() or simply iterating over it would actually execute it.</p>
<p>The results would be disconnected from the DB (simple POCO's) and be appropriately secured unless I specifically asked the framework to track changes for me to make saving easier later.<br>
If a calling user asks for "select * from Table" configuration of a secure where clause should be a key feature of any ORM "micro" or not.</p>
<p>My issue tends to boil down to the fact that all these ORM's claiming to be better than EF appear to be so on face value, but as soon as you start drilling in to the complex scenarios they fall short of features resulting in me having to extend or build tons of framework around the ORM.</p>
<p>So the article makes the comparison of OrmLite's 89k cloc to EF's 514k cloc in the chart at the begining but it's forgetting that there's a bunch of stuff in that extra 400k cloc that OrmLite can't do.</p>
<p>Unless i'm missing something?</p>
<p>I recently asked the Dapper guys about how implementing a Dapper based back end for OData might look I simply got a one liner "you'd have to write your own version of LINQ to SQL as Dapper doesn't do that" ...</p>
<p>So Dapper can execute a query, and map the results to an Object graph, but it can't build the query in the first place. That's half the work is it not?</p>
<p><strong>In short</strong></p>
<p>I'd love to see a "micro-ORM" implementation of an OData or GraphQL or similar API model as those sorts of API's really push the limits of what ORM's can do.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 2
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/pauldotknopf" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/523150?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/pauldotknopf" target="_blank" class="user">pauldotknopf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598345543" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T18:17:11.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>See this: <a href="https://docs.servicestack.net/why-not-odata" rel="nofollow">Why not OData?</a></p>
<p>Also this: <a href="https://docs.servicestack.net/autoquery" rel="nofollow">AutoQuery</a></p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598525437" target="_blank" class="time">
                                    <relative-time datetime="2020-03-13T03:03:09.0000000&#x2B;00:00">
                                        Mar 13, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/TehWardy/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TehWardy">@TehWardy</a> You're living under the misguided assumption that EF's complexity is necessary, it's absolutely not, you have more flexibility and freedom with a typed ORM which gives you direct, clean access to RDBMS features, not some App-level Object Mapping framework that you're a slave to. Doesn't look like you've noticed that none of the new &amp; modern NoSQL data persistence technologies have anywhere the complexity, tracking and impedance mismatch of Heavy ORMs. Something other thriving OSS platforms are aware as their popular ORMs do not suffer EF's complexity tax. They provide straight-forward APIs to access their underlying features, essentially the goal of most API libraries which provide typed APIs to a networked resource, for some reason Heavy ORMs is the only Exception which some ("enterprise" .NET/Java) devs seem to cling on to as the only one true way they could ever envisage code could ever interact with a database.</p>
<p>Your ideal ORM API is not my ideal ORM API which is to provide a clean typed API over RDBMS queries so you know exactly the SQL that's going to be executed - i.e. exactly what OrmLite does where its abstraction is only concerned about offering cross-RDBMS compatible implementation for portability + simplified UX, not some hidden N+1 + tracking magic that EF deems appropriate.</p>
<p>Your OData is a great example of unnecessary complexity, pure unnecessary bloat, resulting in slow, implementation coupled APIs that you haven't got a dream of feasibly being able refactor &amp; replace its implementation without breaking external clients - effectively breaking the golden rule of API design. Read Paul's links if you want to see how you can build a simpler, cleaner &amp; faster data-driven services using a Micro ORM (OrmLite) without any of the pitfalls of OData. It's no wonder Netflix abandoned their failed experiment with it and any company that cares about performance wont go near it.</p>
<p>Happy that you're productive with EF, but you've got very little chance in convincing many devs that have made the switch to Micro ORMs that Heavy ORMs are still the ultimate sophistication of how a ORM should be designed an implemented - many of us came from there, we're not going back.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png" class="emoji">‚ù§Ô∏è</g-emoji> 3
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598603888" target="_blank" class="time">
                                    <relative-time datetime="2020-03-13T08:19:06.0000000&#x2B;00:00">
                                        Mar 13, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>I don't agree with the bulk of points in that Odata article, for example the supposed "tight coupling of internals" problem highlighted is not present in my stack but that's a far more complex and different discussion. I was using OData as an example mainly because of the complexity in scenarios that it exposes us to only, even Microsoft who pushes OData heavily states that best practice is to have N-Tier separation and promotes the use of both an API model and a DB model, the mapping for that is an entirely different issue though that's not worth discussion here.</p>
<p>The article seems to suggest that AutoQuery is an alternative to OData which it just isn't.<br>
the fact is, as the article points out "the OData query-space can reference any table and any column that was exposed.", not quite true but the premise is ... you have a model (that model doesn't have to be the same as your data model, but you can build any question on any part of the API model,</p>
<p>Essentially all i'm asking is that an ORM should be able to handle exactly that, and when I ask it a question I should be able to tell it "I want my question asked in this business context" which for the bulk of queries in enterprise applications boils down to "based on what the user making the call has access to", which in my case is a small cut of every table in the DB.</p>
<p>If the answer it seems is to just avoid asking the question then it's not really answer is it?<br>
This comes back to my Dapper point above, can Dapper really claim it's faster than EF when it only solves half the problem!</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598652307" target="_blank" class="time">
                                    <relative-time datetime="2020-03-13T10:23:34.0000000&#x2B;00:00">
                                        Mar 13, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <blockquote>
<p>The article seems to suggest that AutoQuery is an alternative to OData which it just isn't.</p>
</blockquote>
<p>AutoQuery is a solution for being able to rapidly develop data-driven Services, it's not a replacement for OData in that it has no intention to copy any of its complexity or design flaws. AutoQuery has its own goal of letting you define your data-driven Services "contract-first" that AutoQuery them implements your intentions using its extensible query model that can be extended with your own conventions. It also lets you easily re-define existing AutoQuery Services with a custom implementation that's sourced from a different or multiple data sources without breaking external clients, i.e. what all API designs should allow for.</p>
<p>AutoQuery is one of ServiceStack's most loved features, if you've never used AutoQuery in the real-world you're not in a position to evaluate and compare its development model &amp; productivity vs OData.</p>
<p>If the default way to develop "OData" leads to a pit of failure and you have to develop N-Tier onion architectures in order to use OData "the recommended way" then there's not going to be much benefit using it, realistically most devs are just going to go with the low-effort default approach, this is just a caveat they like to add so they can say OData is capable of creating non-brittle APIs - just N-Tier it!</p>
<p>Microsoft used to push OData heavily when they initially developed it due to their invested significantly in creating it, I also remember at the time there were HTTP knowledgeable MS Employees who cringed at its catch-phrase "the best way to REST" since it's a horrible example of REST-ful API design (IMO it's also a general failure in software design &amp; complexity as well), but relatively no-one cares anymore since it's a waning technology that never caught traction outside of MS's PR bubble where it's now considered a long forgotten blob of complexity with anyone in that space is now using GraphQL. I expect OData to continue to have a maintenance-mode long shelf-life in MS products but have zero expectations it will ever see any kind of resurgence in the wider industry - which is the typical end for over-architected technologies since it's typically not worth the dev effort trying to re-purpose a blob of complexity (see also WCF-REST). An example of this in OData-land is how many years it took the organization with full-control over developing .NET Core to also port OData to .NET Core vs the 0 time &amp; effort it took for AutoQuery where its exact same implementation continues to work and be supported <a href="https://docs.servicestack.net/why-servicestack#multiple-hosting-options" rel="nofollow">everywhere ServiceStack runs</a>.</p>
<p>Because AutoQuery's a simple &amp; clean implementation that's just a regular ServiceStack Service it's also able to take advantage of ServiceStack's entire <a href="https://docs.servicestack.net/why-servicestack#multiple-clients" rel="nofollow">ecosystem of features</a> around Services where it's available in <a href="https://docs.servicestack.net/add-servicestack-reference" rel="nofollow">each supported language</a> using clean, idiomatic typed APIs and all endpoint formats like CSV where you can load the <a href="https://docs.servicestack.net/csv-format#rest-usage" rel="nofollow">results of your AutoQuery CSV results</a> directly into spreadsheets or imported in RDBMS's that support it. You can even call AutoQuery Services <a href="https://docs.servicestack.net/grpc#protobuf-net-inheritance" rel="nofollow">from our latest feature - gRPC!</a>. How many more years will it take OData services to be consumable from gRPC?</p>
<p>That's just one example of why you <a href="https://docs.servicestack.net/service-complexity-and-dto-roles" rel="nofollow">should avoid complexity</a>, your business logic becomes bound to a blob of complexity that becomes harder to re-purpose and most over-architected technologies are destined to be replaced by cleaner, simpler &amp; more focused solutions. E.g. the missing EF6 features not in EF Core and their behavioral differences is still preventing many organizations from being able to move to .NET Core, by contrast OrmLite uses the same implementation on both .NET Framework/.NET Core with perfect source-code compatibility rendering it effortless to port any business logic using it to .NET Core, whilst existing .NET Framework users continue to enjoy new features with each release and can remain confident in knowing that when the time comes it will be trivial to port to .NET Core.</p>
<blockquote>
<p>I should be able to tell it "I want my question asked in this business context"</p>
</blockquote>
<p>Which is the inspiration behind many leaky heavy abstractions and impedance mismatches and what causes Heavy ORMs to earn their bloated complexity reputations. This was also the prevailing attitude in the early 2000's when Enterprise SOA was the dominant force (and everyone should develop SOAP services) and dictated using an OOP DB abstraction without concern for the underlying RDBMS. When the hype died and they were evaluated on their own merits, it was found wanting with the industry quickly moving to simpler RESTful JSON APIs built with CoC frameworks and libraries.</p>
<p>Most data access technologies provide a clean typed access to the underlying data technology features. So yeah to use a Micro ORM you need to know SQL since that's what their APIs are modeled after. The approach then becomes "how do I best implement my business logic with this data access technology".</p>
<blockquote>
<p>Dapper really claim it's faster than EF when it only solves half the problem!</p>
</blockquote>
<p>You're misappropriating EF features with features every ORM should also have a desire to have given you're under the assumption that every other data access technology is just a partial (half!) implementation of EF, a consequence of relying on needing to work within EF's feature-set where you'd likely struggle if you had to develop Apps using different platforms or against a different DB technologies. Don't bother looking for features relying on modification tracking to ever appear in Micro ORMs, it's an example of an unnecessary complexity that'll never be implemented. Quite simply, if you need EF features don't switch, EF will be around forever - as the catchphrase goes, you'll never get fired for choosing it.</p>
<p>But to answer your question, yeah you can claim to be faster if you're accomplishing the same results, faster.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mikependon" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/591015?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mikependon" target="_blank" class="user">mikependon</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599035744" target="_blank" class="time">
                                    <relative-time datetime="2020-03-14T10:04:00.0000000&#x2B;00:00">
                                        Mar 14, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>Interesting topics, I really like to chip-in my ideas but only on ORM side. Hope to share more here soon.</p>
<p>As of writing this, I do not have any idea of AutoQuery and I am not as deep at OData.</p>
<blockquote>
<p>key things to note here that EF solves that I can't seem to find a solution to in other ORM's the include, and then the sub include are both filtered by the relationship but also on filter conditions applied to the table regardless of context in which that table is questioned.</p>
</blockquote>
<p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/TehWardy/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TehWardy">@TehWardy</a> - I think, a micro-ORM can do solve all the things, whereas EF can't. The EF has abstracted most of the things for you, and that limits you to access the benefits of the underlying storage. It means, you have less control with EF over a what we called micro-ORMs.</p>
<blockquote>
<p>Migration tool - People often forget about the complexity that EF is solving.</p>
</blockquote>
<p>True, and not true. It is based on preference. I can say, EF did not solve any complex problem :) - that's why there are micro-ORMs which allows you to have more control. Of course, you have to write more.</p>
<p>Specifically to Migration Tool, we have developed a DevOps tool and had not used EF code-first as our preference is to not bound it to EF at all. In the end, it is much easy to maintain and solves the complexities of our releases :)</p>
<blockquote>
<p>I've not yet found anything that can match this type of EF solved scenario that didn't require a crap ton of "work arounds" or "patching stuff together"</p>
</blockquote>
<p>Do not generalize this, EF does not even have Batch and Bulk operations, 2nd layer cache, Trace, etc. And if you tend to do that, it requires you a lot of works just to make it work with EF. Also, you are bound to the models at all, and you can't do anything on your model but just to use it on a specific table.</p>
<blockquote>
<p>My ideal ORM would allow me to do something like ...</p>
</blockquote>
<p>I am interested to collaborate and share. I am also an author of one micro-ORM named <a href="https://github.com/mikependon/RepoDb">RepoDb</a>. Can you have a look?</p>
<p>It is a hybrid-ORM which will allow you to do the things of micro-ORMs and macro-ORMs. You will have a lot of benefits while using it, I can even explain and support on this.</p>
<p>You may experience a different test as it has been baked differently.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 3
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599275975" target="_blank" class="time">
                                    <relative-time datetime="2020-03-15T22:51:49.0000000&#x2B;00:00">
                                        Mar 15, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>It's refreshing to have people to talk to about this stuff ... most devs want to avoid this type of problem as it's a minefield of pain whatever path you go down it seems, the trick is picking which mines you step on with some level of "good guess work of the future".</p>
<p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a></p>
<p>I can see you clearly have some big issues with the M$ stack, mostly they are valid too if the stack is used as documented.<br>
The way they document stuff is the "this should get you going" method, not the "this is probably how you should be using it" way ... the main reasoning there I guess is that they want as many people using the technology as possible which is true of any stack vendor.</p>
<p>You seem to be under the impression that OData is ...</p>
<ol>
<li>Not type safe / lacking contract definition.</li>
<li>Tightly bound to a db model.</li>
<li>Specifically an M$ technology.</li>
<li>Over-complicated for complexity's sake.</li>
</ol>
<p>To that I would say ...</p>
<ol>
<li>The OData standard specifically requires an API model definition.</li>
<li>It doesn't have to be, that's a documentation issue.</li>
<li>It's open source, managed and owned by not M$ ... but M$ do have 1,000's of endpoints that use it (their entire cloud platform that they spent billions on uses it for it's entire API model).</li>
<li>That complexity caters for scenarios that from what I can tell are impossible in service stack without a lot of code or the loss of that type safety (as per our discussion on stackoverflow).</li>
</ol>
<p>I've noticed that OData is referenced with regards to the v3 spec and WCF, that version is basically dead, the v4 spec and version runs entirely on .Net Core 3.1 and is actually more complete than it's partner version of EF (the soruce of my frustration right now).</p>
<p>Also what's this ...</p>
<blockquote>
<p>it was found wanting with the industry quickly moving to simpler RESTful JSON APIs built with CoC frameworks and libraries.</p>
</blockquote>
<p>... OData isn't dead, it IS restful and returns JSON by default and my entire point to you centered around my testing efforts on service stack are literally that CoC point (i have that already and don't want to give it up), service stack doesn't seem to do anything by convention it requires explicit definition literally everywhere.</p>
<p>When I say "I should be able to tell it "I want my question asked in this business context" ... i'm not joking, I run a transactional platform and the context of a question is important ... I see a billion euros a week worth of invoice data through the system and users getting back the wrong rowset is not an option, that is by design a complex question nto because M$ said so but simply because it has to be.</p>
<p>As for the "mis-appropriation of features" ... I don't use any of the extended features that didn't get ported to .Net core for that exact reason, I saw the headache coming and avoided it.<br>
The one feature i'm struggling with is expansions when pulling entities from the DB with their children, other ORM's seem to be able to do this but it's pita by comparison and lacks flexibility.</p>
<p>I've had DBA's hand crank queries to answer some of the simpler questions and the way EF handles some of the scenarios actually beats that (it's rare but it happens).<br>
The most complex of the queries i've hit run a 1MB select query and it comes back in incredibly short times, that's how complex the questions are.</p>
<p>That's a requirement imposed on me because of the nature of our DB not due to the framework imposing that, replacing EF with ORmLite or Dapper will not change that, it's been tested extensively.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599275982" target="_blank" class="time">
                                    <relative-time datetime="2020-03-15T22:51:53.0000000&#x2B;00:00">
                                        Mar 15, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mikependon/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mikependon">@mikependon</a></p>
<p>Thanks for the feedback, I can totally see why people say what they say about EF, hell the grief I give M$ on occasion and the EF team is somewhat ridiculous at times because i'm trying to solve problems that simply shouldn't exist.</p>
<p>I'll happily take a look at your ORM :)</p>
<blockquote>
<p>As of writing this, I do not have any idea of AutoQuery and I am not as deep at OData.</p>
</blockquote>
<p>Good place to start, I know here on the Service Stack side OData is seen as some sort of anti-pattern due to the way that M$ documents and recommends using it, I definitely don't use OData as documented so usually don't hit the down sides (like tight binding to the DB structure).<br>
I actually get a lot of flack from the M$ dev teams about my abuse of their tech, but my implementations are cleaner, faster, and more secure than their documented examples.</p>
<p>When discussing it here though, it pays to appreciate the complexity of questions that you can answer with the OData + EF stack WITHOUT having to specifically write any code at all beyond building the class that matches the table by default.</p>
<p>With other stacks like shown here with service stack I've had some interesting conversations with <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a> (sorry mate, I do like to ask the complex questions) on this area and the choice to jump  boils down to a few key points for me ...</p>
<ol>
<li>I should be able to implement what I want as a "base" and extend for specific cases where needed (and only where needed).</li>
<li>I shouldn't have to handle every possible use case of my API explicitly (because my API is consumed in situations I don't have any visibility of).</li>
<li>My clients build a solution using my framework so I can't "build the complete API they want" (meaning it needs to answer questions i haven't thought of)</li>
<li>I can't hand crank blocks of SQL (nor do i have any interest in that / time to do so)</li>
<li>It would be nice if it's free, (I can't test my code stack conversion to Service Stack without buying a licence which is frustrating).</li>
</ol>
<p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a>  I was going to ask you about point 5 actually ... I've converted a few thousand lines of code over to service stack but obvs because my model is more than 10 tables (or whatever the limit is) I can't test it, i'm actually seriously interested in at least spinning it up to see if that performance gain is really there (although I do have a query generation problem to solve) as ORMLite only solves some of the scenarios I have.</p>
<p>Some points of discussion had on stackoverflow ...</p>
<ul>
<li><a href="https://stackoverflow.com/questions/60686237/servicestack-is-context-based-routing-specified-in-the-url-possible" rel="nofollow">https://stackoverflow.com/questions/60686237/servicestack-is-context-based-routing-specified-in-the-url-possible</a></li>
<li><a href="https://stackoverflow.com/questions/60678495/understanding-the-request-lifecycle-and-routing-mechanism-in-service-stack" rel="nofollow">https://stackoverflow.com/questions/60678495/understanding-the-request-lifecycle-and-routing-mechanism-in-service-stack</a></li>
</ul>
<p>The key thing here is that as the technical lead on my own stack I should be able to pick the pieces that work for me (EF admittedly doesn't give me that, it's all of that half million lines or nothing - ish) ... but then having picked my pieces I should be able to build solutions around them as needed.</p>
<p>When I talk about my ideal ORM, i currently don't think it exists but then i'm very picky.</p>
<p>Key features I would like to see in an ORM which would make building my own API easy are ...</p>
<ul>
<li>CRUD without a model (so much like OrmLite here or Dapper the ability to just grab a connection and do stuff with T's on it)</li>
<li>Query generation, from either some form of string source or an expression tree.</li>
<li>T based Filters on the DB (which is why i don't want to get involved with the SQL construction).</li>
<li>The ability to point the ORM at a context class which defines the model and generates migrations for me (EF does this bit incredibly well).</li>
<li>No forced patterns or architecture design.</li>
</ul>
<p>That last point along side the lack of SQL generation from LINQ  is where I feel both Dapper and OrmLite fall short, but this is why I think they are sold as "micro-ORM's" at least in part, they deal with ONLY the problem of talking SQL to SQL servers.<br>
That's not a bad thing as it keeps the framework light, but maybe what's missing here is a LINQ to Sql abstraction (like the one in EF) but not tied to any ORM, one that's pluggable so consumers can override certain behaviour (probably on a tpye by type basis).</p>
<p>consider this sort of query example ...</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> build the query</span>
<span class="pl-k">var</span> <span class="pl-smi">query</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Query</span>&lt;<span class="pl-en">T</span>&gt;()
    .<span class="pl-en">Where</span>(...)
    .<span class="pl-en">Where</span>(...)
    .<span class="pl-en">Select</span>(...)
       .<span class="pl-en">Expand</span>(...)
             .<span class="pl-en">ThenExpand</span>(...)
    .<span class="pl-en">GroupBy</span>(...)
    .<span class="pl-en">OrderBy</span>(...)
    .<span class="pl-en">ToSql</span>();

<span class="pl-c"><span class="pl-c">//</span> then with Dapper I could do ...</span>
<span class="pl-k">var</span> <span class="pl-smi">results</span> <span class="pl-k">=</span> <span class="pl-smi">connection</span>.<span class="pl-en">Query</span>&lt;<span class="pl-en">ResultType</span>&gt;(<span class="pl-smi">query</span>).<span class="pl-en">ToList</span>();</pre></div>
<p>... the key thing to note about this example is that I'm mapping questions presented as OData parameters in to this framework basically allowing the User to build the query they want the API to run, but not only that, the base set is filtered by a preconfigured filter for T based on the users access to rows in the DB, then when they expand in to the subsets those also have a filter applied to them, all of this is automatically injected in to the query.</p>
<p>Now I can see the response here ... "yeh you can do all that with x-ORM" ... you're right, I can ... but I don't want to hand crank all that functionality, EF already handles it for me, the only issue is that I have to take all of EF to get it.</p>
<p>If I could take the query building, as a feature and plug that in to any ORM then I'm free to choose to use OData on top of that if I so please.<br>
If I take service stack I can't do this, I have to pre-think of all the possible queries the user might want to ask and build them in to my API layer providing a pairing of at least 1 DTO + a service method for each possible question.</p>
<p>For CRUD on a single OData endpoint I only require a single generic controller, with a filter on the DB table (a one of linq expression, and one liner) I can filter the table for any user that logs in by applying my own "app role logic or whatever" to the table and i'm done.</p>
<p>Assuming I follow a convention I would then have 1 controller / service and one context class representing my DB then the simple POCO that represents the table (all things I have with service stack) ... the key difference with the OData + Ef stack is that if I want a new endpoint I simply add a new POCO and i'm done, full CRUD implemented "by convention".</p>
<p>is this slower than a handcranked query for each CRUD operation on every possible endpoint query ... yup, do I care that it costs a few extra CPU cycles ... nope, servers are cheap to rent, cloud solutions architects and the dev teams to maintain complex codebases aren't.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599373526" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T06:55:47.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/TehWardy/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TehWardy">@TehWardy</a></p>
<p>Your long rant is basically a list of opinions presented as assertions without substance or concrete examples backing them up. You're under the assumption OData is a necessary complexity full of must have features (that other solutions must be dying to implement) and is the reason why it must be more bloated than everything else, and that somehow by releasing libraries as "throw over the wall OSS" is somehow an indication that MS aren't the only ones fully invested, sponsoring and controlling its implementation, like because its labelled OSS there's no difference between a thriving industry adopted standard and solution like GraphQL which is available in most languages/platforms implemented by different authors vs a corporate sponsored solution like OData, which no-one outside MS's PR bubble cares for.</p>
<p>So I'm going to ignore your opinions of OData as you seem to think it's some kind of holy grail technology that's setting some kind of API Design or software development ambition with features that everyone's dying to copy (instead of them being irrelevant and ignored). I'm assuming your beliefs could only have been formed by having no experience in different languages or OSS platforms &amp; communities where OData has no dev mindshare and zero consideration in modern technology stacks, but sure feel free to keep believing it has a thriving future and your future-proofed systems are just ahead of the curve.</p>
<p>But I will address your inaccurate statements about ServiceStack:</p>
<blockquote>
<p>service stack doesn't seem to do anything by convention it requires explicit definition literally everywhere.</p>
</blockquote>
<p>AutoQuery literally provides the implementation for you, by convention. This is literally the most CoC you can get, you describe what your Service should support and AutoQuery provides the implementation for it. I find it hard to correlate that you spent anytime looking at AutoQuery since the introductory section shows the minimum code for an AutoQuery Service:</p>
<blockquote>
<p>the minimum code required is to just declare a new Request DTO with the table you wish to query:</p>
</blockquote>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FindMovies</span> : <span class="pl-en">QueryDb</span>&lt;<span class="pl-en">Movie</span>&gt; {}</pre></div>
<p>Which can then be queried with all the implicit query conventions that explicit contracts can.</p>
<p>AutoQuery doesn't support not having to define your Service Contract since that's not how APIs should be implemented. You shouldn't be using a Typed language if you don't believe in type-safety benefits, with the most important place of all to have them is on your explicit Service Boundary, but if you're allergic to Types we actually have a solution where you can <a href="https://sharpscript.net/docs/sharp-apis" rel="nofollow">develop .NET APIs without C#</a> with little more boilerplate than the SQL you want executed, which also supports being consumed from <a href="https://sharpscript.net/docs/sharp-apis#user-content-_userapi-page" rel="nofollow">multiple serialization formats</a>, and you don't even need to define your routes as you can use folder &amp; file name conventions. It's a good choice for rapidly develop data APIs for one-off tasks or internal solutions but as they're <a href="https://sharpscript.net/docs/sharp-apis#untyped-apis" rel="nofollow">untyped they're not included in API metadata services</a> or ServiceStack ecosystem of features so we don't recommend encapsulating access to your System behind Untyped APIs like this.</p>
<p>You're basically complaining about having to specify the definition that your Service Contract should have, i.e. having to follow the API best practice of defining a clear service boundary that your API consumers bind to - the <a href="https://docs.servicestack.net/why-remote-services-use-dtos" rel="nofollow">most important contract your system has</a>, that external clients (with different technologies, dev teams, deployment schedules, etc) bind to, whom should be shielded from your Systems internal refactorings and internal schema changes. Service Contracts describes the known features your API has to support should it ever need to change, e.g. if it ever had to add caching, sourced from multiple data sources or from different tables, e.g. when tables are denormalized or if your system starts using CQRS and data needs to be fetched from different read models.</p>
<p>Without an explicit Service Contract it's infeasible to be able to cater to be able to reimplement Services to support this, all you're doing is exposing an API endpoint to an OData binary blob that process opaque OData queries, which isn't any better than handing out a read-only DB connection to your RDBMS, as soon as you have clients binded to your APIs your Systems become frozen forever stuck with having to use OData and your System tables become inhibited to change. If you ever abandon OData like Netflix have, you're abandoning your Customers and all the effort and resources they put into building integrations with your system.</p>
<blockquote>
<p>That last point along side the lack of SQL generation from LINQ is where I feel both Dapper and OrmLite fall short, but this is why I think they are sold as "micro-ORM's" at least in part, they deal with ONLY the problem of talking SQL to SQL servers.</p>
</blockquote>
<p>I don't understand your points about OrmLite falling short by not having a Query Builder sourced from SQL and Expression Trees, when its primary query API is using a typed query builder which generates it SQL from Expression trees, inc. support for custom SQL Fragments if you need to enlist specific RDBMS features. Your example of being able to use the SQL Builder to generate SQL that you can use in a different ORM is literally listed in <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#selecting-multiple-columns-across-joined-tables">OrmLite docs</a></p>
<blockquote>
<p>Thanks to Micro ORM's lightweight abstractions over ADO.NET that maps to clean POCOs, we can also use OrmLite's embedded version of Dapper's QueryMultiple:</p>
</blockquote>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> <span class="pl-smi">q</span> <span class="pl-k">=</span> <span class="pl-smi">db</span>.<span class="pl-en">From</span>&lt;<span class="pl-en">Customer</span>&gt;()
    .<span class="pl-en">Join</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>&gt;()
    .<span class="pl-en">Join</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">Order</span>&gt;()
    .<span class="pl-en">Select</span>(<span class="pl-s"><span class="pl-pds">"</span>*<span class="pl-pds">"</span></span>);

<span class="pl-k">using</span> (<span class="pl-en">var</span> <span class="pl-en">multi</span> <span class="pl-k">=</span> <span class="pl-en">db</span>.<span class="pl-en">QueryMultiple</span>(<span class="pl-en">q</span>.<span class="pl-en">ToSelectStatement</span>()))
{
    <span class="pl-en">var</span> <span class="pl-en">results</span> <span class="pl-k">=</span> <span class="pl-en">multi</span>.<span class="pl-en">Read</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>, <span class="pl-en">Order</span>, 
        <span class="pl-en">Tuple</span>&lt;<span class="pl-en">Customer</span>,<span class="pl-en">CustomerAddress</span>,<span class="pl-en">Order</span>&gt;&gt;(<span class="pl-en">Tuple</span>.<span class="pl-en">Create</span>).<span class="pl-en">ToList</span>();

    <span class="pl-k">foreach</span> (<span class="pl-k">var</span> <span class="pl-smi">tuple</span> <span class="pl-k">in</span> <span class="pl-smi">results</span>)
    {
        <span class="pl-en">Customer</span> <span class="pl-smi">customer</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item1</span>;
        <span class="pl-en">CustomerAddress</span> <span class="pl-smi">custAddress</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item2</span>;
        <span class="pl-en">Order</span> <span class="pl-smi">custOrder</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item3</span>;
    }
}</pre></div>
<p>The equivalent API for selecting multiple tables from a single query in OrmLite looks like:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> <span class="pl-smi">q</span> <span class="pl-k">=</span> <span class="pl-smi">db</span>.<span class="pl-en">From</span>&lt;<span class="pl-en">Customer</span>&gt;()
    .<span class="pl-en">Join</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>&gt;()
    .<span class="pl-en">Join</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">Order</span>&gt;()
    .<span class="pl-en">Where</span>(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">x</span>.<span class="pl-smi">CreatedDate</span> <span class="pl-k">&gt;=</span> <span class="pl-k">new</span> <span class="pl-en">DateTime</span>(<span class="pl-c1">2016</span>,<span class="pl-c1">01</span>,<span class="pl-c1">01</span>))
    .<span class="pl-en">And</span>&lt;<span class="pl-en">CustomerAddress</span>&gt;(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">x</span>.<span class="pl-smi">Country</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Australia<span class="pl-pds">"</span></span>);

<span class="pl-k">var</span> <span class="pl-smi">results</span> <span class="pl-k">=</span> <span class="pl-smi">db</span>.<span class="pl-en">SelectMulti</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>, <span class="pl-en">Order</span>&gt;(<span class="pl-smi">q</span>);

<span class="pl-k">foreach</span> (<span class="pl-k">var</span> <span class="pl-smi">tuple</span> <span class="pl-k">in</span> <span class="pl-smi">results</span>)
{
    <span class="pl-en">Customer</span> <span class="pl-smi">customer</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item1</span>;
    <span class="pl-en">CustomerAddress</span> <span class="pl-smi">custAddress</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item2</span>;
    <span class="pl-en">Order</span> <span class="pl-smi">custOrder</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item3</span>;
}</pre></div>
<p>I hope you realize you can't just have a generic SQL Builder that generates SQL for all queries that works with all ORMs and across all RDBMS's like your proposing in your Example right? There are subtle differences between each RDBMS which needs to be abstracted so that it generates the right SQL for each specific RDBMS Dialect. There's also differences between RDBMS versions in what features it supports which you have to account for (i.e. some of the value Typed ORMs provide). So when you call <code>db.From&lt;T&gt;()</code> you're getting back a Typed Expression Builder tied to an RDBMS Dialect. Each ORM also handles how they map from RDBMS result-sets to .NET Models differently so you're not going to be able to even share POCO models when you start making use of ORM specific features, e.g. All complex Types in OrmLite that aren't <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#reference-support-poco-style">marked as POCO References</a> are blobbed using a <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#pluggable-complex-type-serializers">pluggable Complex Type Serializer</a> that can be configured per RDBMS Provider, I don't know of another ORM which supports that which is going to inhibit Model reuse.</p>
<p>So it doesn't sound like your utopia of mixing ORMs data models and their typed SQL builders is going to come to pass, but if you're just after a SQL Query Builder than you may want to checkout <a href="https://github.com/sqlkata/querybuilder">SqlKata</a>.</p>
<p>But if you want to keep using OData then you should only be considering EF, no-one in .NET outside MS is going to be wasting their efforts trying to support it. You're going to forever use whatever MS provides, who are the only ones investing any resources and effort advancing OData.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599439921" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T09:47:04.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a>  i'm not ranting, sorry if you feel that way ... I thought this was a friendly discussion.</p>
<p>I'd also like to point out that i'm about 80% of the way through making the code work with Service Stack but i'm currently stuck on a few things (understanding this AutoQuery behaviour is actually one of them, so thanks for that). In addition to that i'm constantly sharing the information you give me internally to get further feedback from my team.</p>
<p>I'm not adverse to dropping the M$ stack entirely (again why i'm here), I just need to prove to the business that I can deliver the problem domain under the new stack without too much fallout and in a timely AND cost effective fashion (OData + EF is free after all which means something to a small business like us).</p>
<p>The fact that i'm using OData here is not out of some misguided loyalty to it or M$ it's more that it presents certain complex challenges to ORM solutions so acts as a good example of showing the worst cases that an ORM may need to face.<br>
OData and GraphQL have a lot of common features in their design ethos and yet you don't seem as adverse to GraphQL.</p>
<p>Sure the M$ implementation of OData is horrendously bad in places but to conflate the implementation with the standard (which is what OData is) is out right wrong.<br>
As you say i'm just throwing assertions around and not backing them up lets take <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/pauldotknopf/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/pauldotknopf">@pauldotknopf</a> 's blog post from earlier, in the first part of the article he straight up begins with a bunch of incorrect assertions without backing them up ...</p>
<blockquote>
<p>There is virtually no contract. A service consumer has no idea how to use the service (for example, what are valid Command arguments, encoding expectations, and so on).</p>
</blockquote>
<p>... it's wrong because they actively push the use of metadata based descriptions for the entire model that you're exposing and even go as far as defining the definition of that metadatas schema ...<br>
<a href="http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part3-csdl.html" rel="nofollow">http://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part3-csdl.html</a></p>
<blockquote>
<p>The interface errs on the side of being too liberal in what it will accept.</p>
</blockquote>
<p>... that's just an assertion, the very thing you're accusing me of.</p>
<blockquote>
<p>The contract does not provide enough information to consumers on how to use the service. If a consumer must read something other than the service‚Äôs signature to understand how to use the service, the factoring of the service should be reviewed.</p>
</blockquote>
<p>OData is repeatedly comprared to WCF SOAP Services for some reason by both you and <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/pauldotknopf/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/pauldotknopf">@pauldotknopf</a> in his article (which I find odd as they have literally nothing in common) EXCEPT ... SOAP had a WSDL description, you could use the tools to generate your client code.<br>
OData doesn't require tools, it has an XML based description, as stated above the schema for that is well documented and anything that can read XML can understand OData schemas and thus consume with strong typing the service.</p>
<p>I go a step further and expose metadata relevant to each endpoint on the endpoint itself to avoid the caller having to rely on a large blob of meta for which they want a small portion (IMO this should be the standard).</p>
<p>I could go on but my "opinions" (however documented and fact based they may be) regarding OData aren't wanted here.</p>
<p>Again .. The reason I pointed at OData was that it generates complex "real world questions" I have to build an API to answer.</p>
<p>Your examples are interesting and do solve the problem in the event that I handle the question or use AutoQuery to do this for me ... can AutoQuery do this with my own business logic in the middle something like this (taking the OrmLite example) ...</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> <span class="pl-smi">q</span> <span class="pl-k">=</span> <span class="pl-smi">db</span>.<span class="pl-en">From</span>&lt;<span class="pl-en">Customer</span>&gt;()
        .<span class="pl-en">Where</span>(...)
    .<span class="pl-en">Join</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>&gt;()
        .<span class="pl-en">Where</span>(...)
    .<span class="pl-en">Join</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">Order</span>&gt;()
         .<span class="pl-en">Where</span>(...)
    .<span class="pl-en">Where</span>(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">x</span>.<span class="pl-smi">CreatedDate</span> <span class="pl-k">&gt;=</span> <span class="pl-k">new</span> <span class="pl-en">DateTime</span>(<span class="pl-c1">2016</span>,<span class="pl-c1">01</span>,<span class="pl-c1">01</span>))
    .<span class="pl-en">And</span>&lt;<span class="pl-en">CustomerAddress</span>&gt;(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">x</span>.<span class="pl-smi">Country</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Australia<span class="pl-pds">"</span></span>);

<span class="pl-k">var</span> <span class="pl-smi">results</span> <span class="pl-k">=</span> <span class="pl-smi">db</span>.<span class="pl-en">SelectMulti</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>, <span class="pl-en">Order</span>&gt;(<span class="pl-smi">q</span>);

<span class="pl-k">foreach</span> (<span class="pl-k">var</span> <span class="pl-smi">tuple</span> <span class="pl-k">in</span> <span class="pl-smi">results</span>)
{
    <span class="pl-en">Customer</span> <span class="pl-smi">customer</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item1</span>;
    <span class="pl-en">CustomerAddress</span> <span class="pl-smi">custAddress</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item2</span>;
    <span class="pl-en">Order</span> <span class="pl-smi">custOrder</span> <span class="pl-k">=</span> <span class="pl-smi">tuple</span>.<span class="pl-smi">Item3</span>;
}</pre></div>
<p>... if I understand this correctly this is the equivilent of a query that returns an expanded subset of properties too.</p>
<ul>
<li>Does this support filtered joins "in this manner"?</li>
<li>Can I configure AutoQuery / ORMLite to apply the nested Where clauses ANY time a table of that type is used anywhere in any query?</li>
</ul>
<p>Essentially the reasoning here is that from the users information in the request (like an auth token for example), I have to filter the db down to the stuff they can see in every table then execute my question on what's left (standard multi-tenancy issue basically).</p>
<p>From there the logic is only as complex as the user question asked which it sounds like AutoQuery might be able to limit to a problem domain that's already coded for which is perfect!</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/pauldotknopf" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/523150?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/pauldotknopf" target="_blank" class="user">pauldotknopf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599517294" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T12:48:20.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/TehWardy/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TehWardy">@TehWardy</a> quick question, since you are considering AutoQuery, I take it that the OData solution isn't deployed yet? You are still in the research phase? Is this a new solution?</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599523648" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T13:02:14.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>OData is lumped together with WCF SOAP because it's from the organization that's continually dumping bloated over-architected solutions onto .NET Devs only to replace them as they fall out of favor as they've done with their numerous earlier Web Services, Web and ADO.NET Data provider frameworks.</p>
<p>The only typed client libraries that's going to consume OData endpoints are OData clients, which inversely can only be used to consume OData endpoints. They're 2 blobs of complexity on either side talking to each other using a complicated standard they made up (that no-one else is using).</p>
<p>Contrast with AutoQuery which are just regular Web Services which can be easily consumed by any HTTP Client or with a Typed API by any of ServiceStack's generic Service Clients in any language since it's just accepting / returning clean POCO DTOs that are de/serialized with the clients chosen serialization format.</p>
<p>It's hard to express just how ugly and unnecessarily complicated WSDL's and XML generated typed proxies are vs ServiceStack's zero-effort / no need to code-gen any types or clients since you can use your Services clean POCO DTOs it was defined with, or if you don't want to share .NET Types, use <a href="https://docs.servicestack.net/add-servicestack-reference" rel="nofollow">Add ServiceStack Reference</a> to generate a mirror of the server DTOs on the client in their supported language. In addition to being simpler, cleaner &amp; faster it's also much more versatile since we're also able to include richer markup like .NET Interfaces and Attributes in client DTOs which allows for even richer models than trying to adhere to some complicated language-agnostic/common-denominator standard they've invented to achieve the same purpose.</p>
<p>You want to differentiate them, but OData's standard and their implementations are cut from the same cloth, they're made for each other by the same organization pushing both. In contrast to their slogan, no-one's reading the standard thinking "wow that nested alien URL structure really is the Best Way to REST!" Anyone who really cares about APIs are using the ideal, semantically correct <a href="https://en.wikipedia.org/wiki/Clean_URL" rel="nofollow">Clean URL structures</a> which are going to be technology-agnostic in that you're not going to be able to tell what technology was used to implement the API, so when scaling or evolving their system where the underlying technology (or even language) used changes they wont have to break their existing client ecosystem because they're already using the ideal API they wish to provide. You can refer to <a href="https://developer.github.com/v3/">GitHub API Docs</a> for a great example of HTTP API Design.</p>
<p>By contrast you can tell when an API is implemented by OData by its uniquely ugly URL which will forever need to be implemented by OData.</p>
<h3>Presenting UberData!</h3>
<p>Anyway I digress, since you're a fan of low-effort data APIs with implicit untyped service contracts you might like this quick script I've just added to the rockwind demo in <a href="https://github.com/sharp-apps/rockwind/commit/de7770c8a0136f63152bcb27e42821544dc623bf">this commit</a>:</p>
<h3><a href="https://github.com/ServiceStack/mix/blob/master/apps/rockwind/uberdata/_table.html">uberdata/_table.html</a></h3>
<pre><code>```code
`SELECT * FROM ${table}` |&gt; to =&gt; sql
[] |&gt; to =&gt; filters
'format,orderby,limit,offset'.split(',') |&gt; to =&gt; ignore
#each qs.Keys where !ignore.contains(it.lower())
    `${it} = @${it}` |&gt; addTo =&gt; filters
/each
#if !isEmpty(filters)
`${sql} WHERE ${join(filters, ' AND ')}` |&gt; to =&gt; sql
/if
#if qs.orderBy &amp;&amp; !qs.orderBy.isUnsafeSqlFragment()
    `${sql} ORDER BY ${qs.orderBy}` |&gt; to =&gt; sql
/if
#if qs.limit
    `${sql} LIMIT ${qs.limit.toInt()}` |&gt; to =&gt; sql
/if
#if qs.offset
    `${sql} OFFSET ${qs.offset.toInt()}` |&gt; to =&gt; sql
/if
sql |&gt; dbSelect(queryDictionary) |&gt; return
```
{{htmlError}}
</code></pre>
<p>I'm calling this script <strong>uberdata</strong> because it provides low-effort, flexible untyped data access to your RDBMS tables which anti-types-ers should love.</p>
<p>Which you can drop this in your <a href="https://sharpscript.net/docs/sharp-pages" rel="nofollow">ServiceStack App configured with SharpPagesFeature</a> <code>#Script</code> plugin which will let you query any of your tables, querying any of your columns, including support for paging and custom ORDER BY's and supports returning results in any of your registered Content Type Formats.</p>
<blockquote>
<p>Note: this solution is completely free &amp; unrestricted as it doesn't use any typed OrmLite models, it's not a ServiceStack Service and all of <code>#Script</code> is completely free &amp; unrestricted to use.</p>
</blockquote>
<h4>Gist Desktop App</h4>
<p>You can run &amp; play around with this App locally as it's published as a <a href="https://sharpscript.net/docs/gist-desktop-apps" rel="nofollow">Gist Desktop App</a> which you can run with our <a href="https://docs.servicestack.net/netcore-windows-desktop" rel="nofollow">app dotnet tool</a>:</p>
<pre><code>$ dotnet tool -g app
</code></pre>
<p>Then run the Gist Desktop App with:</p>
<pre><code>$ app open rockwind
</code></pre>
<p>Where it will download the Gist and run it in the app's local Chromium Desktop Browser.</p>
<h4>Local Sharp App</h4>
<p>Or if you want you can download <a href="https://github.com/sharp-apps/rockwind">sharp-apps/rockwind</a> and launch it with:</p>
<pre><code>$ app
</code></pre>
<p>Where you'll be able to make changes in real-time and get instant feedback while the app's running.</p>
<h4>Deployed Gist Desktop App</h4>
<p>This Gist App is also <a href="https://sharpscript.net/docs/deploying-sharp-apps" rel="nofollow">deployed as a .NET Core App</a> so you'll also be able to try it out at <a href="http://rockwind-sqlite.web-app.io" rel="nofollow">rockwind-sqlite.web-app.io</a>:</p>
<p>So you can use it to query any of your RDBMS tables using the nice page-routing based API, e.g:</p>
<ul>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/customer" rel="nofollow">/uberdata/customer</a></li>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/employee" rel="nofollow">/uberdata/employee</a></li>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/product" rel="nofollow">/uberdata/product</a></li>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/category" rel="nofollow">/uberdata/category</a></li>
</ul>
<p>It's available in all registered formats, if viewed from a browser it will return the <a href="https://docs.servicestack.net/html5reportformat" rel="nofollow">Auto HTML5 Report Format</a>, you can use the <code>?format</code> queryString to specify the content type you want it in, e.g:</p>
<ul>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/customer?format=json" rel="nofollow">/uberdata/customer?format=json</a></li>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/customer?format=csv" rel="nofollow">/uberdata/customer?format=csv</a></li>
</ul>
<p>CSV is particularly nice because you can save it in a <code>.csv</code> file and open up directly in a spreadsheet.</p>
<p>Or if JSON is the one true format you <a href="https://sharpscript.net/docs/sharp-apis#user-content-hello-api-page" rel="nofollow">force it to always return a specific Content-Type</a> with:</p>
<pre><code>|&gt; return({ format: 'json' })
</code></pre>
<p>It uses parameterized SQL it's safe from SQL injection (The free-text <code>?orderBy</code> is also validated) so you can safely query any of your columns:</p>
<ul>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/customer?country=Germany" rel="nofollow">/uberdata/customer?country=Germany</a></li>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/product?categoryId=1" rel="nofollow">/uberdata/product?categoryId=1</a></li>
</ul>
<p>Including Paging &amp; Order By:</p>
<ul>
<li><a href="http://rockwind-sqlite.web-app.io/uberdata/customer?country=Germany&amp;offset=5&amp;limit=5&amp;orderBy=CompanyName" rel="nofollow">/uberdata/customer?country=Germany&amp;offset=5&amp;limit=5&amp;orderBy=CompanyName</a></li>
</ul>
<p>So it's a pretty flexible "uberdata" API, a nice quality about it is because it uses a clean, technology-agnostic URL and queryString API and returns a flat tabular data structure, it can later be easily re-implemented by a typed Service when you know which features you want to allow consumers to query and want to formalize it in a typed Service Contract.</p>
<h4>bye uberdata :(</h4>
<p>Moving back to AutoQuery, yes you can define the AutoQuery Service with joins, where it's joined using an <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#typed-sqlexpression-support-for-joins">implicit JOIN Reference</a>, e.g:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span> <span class="pl-en">QueryJoinedCustomers</span> : <span class="pl-en">QueryDb</span>&lt;<span class="pl-en">Customer</span>&gt;,
    <span class="pl-en">IJoin</span>&lt;<span class="pl-en">Customer</span>,<span class="pl-en">CustomerAddress</span>&gt;, <span class="pl-en">IJoin</span>&lt;<span class="pl-en">Customer</span>,<span class="pl-en">Order</span>&gt;
{
    <span class="pl-c"><span class="pl-c">//</span>.. Typed Property Queries you want to allow</span>
}</pre></div>
<p>Then you can further augment the query in a <a href="https://docs.servicestack.net/autoquery-rdbms#custom-autoquery-implementations" rel="nofollow">custom AutoQuery implementation</a> but<br>
AutoQuery Services are expected to return a single Tabular result, so you'd normally return a single flat POCO with all fields from all tables you want returned, e.g. <code>QueryDb&lt;Customer,CustomerJoinResult&gt;</code>.</p>
<p>But as you're going to use your custom API to execute the query you should also be able to return a nested result like:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">CustomerJoinResult</span>
{
    <span class="pl-k">public</span> <span class="pl-en">Customer</span> <span class="pl-smi">Customer</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-en">Address</span> <span class="pl-smi">Address</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
    <span class="pl-k">public</span> <span class="pl-en">Order</span> <span class="pl-smi">Order</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div>
<p>Where your custom implementation would look something like:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyQueryServices</span> : <span class="pl-en">Service</span>
{
    <span class="pl-k">public</span> <span class="pl-en">IAutoQueryDb</span> <span class="pl-smi">AutoQuery</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-c"><span class="pl-c">//</span>Override with custom implementation</span>
    <span class="pl-k">public</span> <span class="pl-k">object</span> <span class="pl-en">Any</span>(<span class="pl-en">QueryJoinedCustomers</span> <span class="pl-smi">query</span>)
    {
        <span class="pl-k">var</span> <span class="pl-smi">q</span> <span class="pl-k">=</span> <span class="pl-smi">AutoQuery</span>.<span class="pl-en">CreateQuery</span>(<span class="pl-smi">query</span>, <span class="pl-smi">Request</span>); <span class="pl-c"><span class="pl-c">//</span>pre-populated with API Request</span>
        <span class="pl-smi">q</span>.<span class="pl-en">Where</span>&lt;<span class="pl-en">Customer</span>&gt;(<span class="pl-smi">c</span> <span class="pl-k">=&gt;</span> ...)
         .<span class="pl-en">And</span>&lt;<span class="pl-en">Customer</span>,<span class="pl-en">CustomerAddress</span>&gt;((<span class="pl-smi">c</span>,<span class="pl-smi">a</span>) <span class="pl-k">=&gt;</span> ...)
         .<span class="pl-en">And</span>(<span class="pl-smi">c</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">x</span>.<span class="pl-smi">CreatedDate</span> <span class="pl-k">&gt;=</span> <span class="pl-k">new</span> <span class="pl-en">DateTime</span>(<span class="pl-c1">2016</span>,<span class="pl-c1">01</span>,<span class="pl-c1">01</span>))
         .<span class="pl-en">And</span>&lt;<span class="pl-en">CustomerAddress</span>&gt;(<span class="pl-smi">a</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">a</span>.<span class="pl-smi">Country</span> <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Australia<span class="pl-pds">"</span></span>);

        <span class="pl-k">var</span> <span class="pl-smi">results</span> <span class="pl-k">=</span> <span class="pl-smi">db</span>.<span class="pl-en">SelectMulti</span>&lt;<span class="pl-en">Customer</span>, <span class="pl-en">CustomerAddress</span>, <span class="pl-en">Order</span>&gt;(<span class="pl-smi">q</span>);

        <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">CustomerJoinResponse</span> {
            <span class="pl-smi">Results</span> <span class="pl-k">=</span> <span class="pl-smi">results</span>.<span class="pl-en">Map</span>(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">CustomerJoinResult</span> {
                <span class="pl-smi">Customer</span> <span class="pl-k">=</span> <span class="pl-smi">x</span>.<span class="pl-smi">Item1</span>,
                <span class="pl-smi">Address</span> <span class="pl-k">=</span> <span class="pl-smi">x</span>.<span class="pl-smi">Item2</span>,
                <span class="pl-smi">Order</span> <span class="pl-k">=</span> <span class="pl-smi">x</span>.<span class="pl-smi">Item3</span>,
            })
        }
    }
}</pre></div>
<p>You can also add the joins in your Custom implementation but then the users wouldn't be able to query the joined tables.</p>
<p>Anyway spent to much time here, that's about all from me, back to work...</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599561085" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T14:17:27.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/pauldotknopf/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/pauldotknopf">@pauldotknopf</a>  I have an existing solution implemented with an OData based API layer, my issue generally isn't with OData, I think <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a>  here has issues with "ugly URLs" in OData (not unreasonable to be honest if you lok at them encoded they can appear pretty ugly).</p>
<p><strong>The background for my "problem domain"</strong></p>
<p>The reason we use OData is because it allows the client to specify the question they want to ask instead of me stating to the client "these are the questions  you can ask" which is key here.<br>
In <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a> example from the last comment for example in order to achieve the join result in AutoQuery I have to provide the endpoint with a method that implements that particular question joined in that particular way.</p>
<p>My issue is that I don't know that that particular join is something the client wants at the time I'm writing the code and I don't want a support call to implement a new API method everytime they have a new question to ask the API.</p>
<p>I know you guys are highly against OData but the key thing this offers is "within the confines of the type safety as defined by the contract emtadata which defines the tpyed sets that can be questioned" the user can "build a question in a URL to confirm to even the most complex of business scenarios" and yes the nature of the question they can ask CAN get complex but it's on them to decide that not me, and forcing them to only ask "pre-built questions" won't cut it.</p>
<p>The issue is that our clients are fortune 500 companies with big complex "poorly deisgned" systems like SAP implementations and often are constrained by having to work to a standard that that system implements, and OData is one of those standards.<br>
This is where OData excels because the provider (this case SAP / IBM / Seimans) that delivers the platform to our client will provide functionality to allow them to interact with systems through expensive (like half a million $) "connectors" which are specifically designed to a given spec and whilst AutoQuery looks great I can't tell a client "sorry this is how we work because it's better for us" I have to conform to the provisions that their system can handle.</p>
<p>With the netflix example netflix can decide how people communicate with them, with our platform we offer business services that connect between such systems and are forced to interact with those systems in the way that they support so i'm not dealing with an "in an ideal world" scenario.</p>
<p><strong>With that in mind</strong><br>
Given that the clients system works a given way, the bulk of my questions are around this area and making my API layer fit to my clients requirements.<br>
This is arguably not a "normal" API delivery scenario that most companies have where they can essentially dictate to partners how their systems work.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599595812" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T15:21:15.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>My issue with OData is its unnatural complexity, poor encapsulation, slow implementation, poor promotion of API design &amp; practices; basically everything you should be avoid having exposed beyond your Service layer whose goal is supposed to provide an interoperable layer that <a href="https://docs.servicestack.net/service-complexity-and-dto-roles#services" rel="nofollow">encapsulates your Systems complexity</a> - all goals OData fails hard at.</p>
<p>Allowing clients to be able to construct adhoc joins to System tables is even worse tight-coupling, which you have even less hope of being able to make changes without breaking existing clients. Might as well give out an RDBMS connection string and give them maximum flexibility.</p>
<p>Apart from promoting poor practices ,I have a <a href="https://docs.servicestack.net/service-complexity-and-dto-roles#softwares-biggest-enemy" rel="nofollow">high intolerance against complexity</a> and will go for the simplest, most elegant solution that accomplishes my needs every time. Apart not having to spend any time fighting my tools and libraries, my creations enjoy a rare longevity since I've been building systems with the same libraries for over a decade, which have survived many generations of alternative solutions and even new .NET runtimes. What does change over time is the <a href="https://github.com/NetCoreApps/TechStacks#recommended-net-spa-stack">best UI stack to use of the day</a> and even the platform it runs on, but my backend technologies and existing clean, well-defined ServiceStack APIs remain unchanged, it'll just gain more services + functionality.</p>
<p><a href="https://servicestack.net/" rel="nofollow">servicestack.net</a> is another example, it was originally hosted on Mono/Linux (AFAIK the first .NET web framework that supported Linux/Mono). Mono had a number of instability issues which required restarting nginx every couple of months, and when Novell dumped the Mono/Ximian team in 2011 they lost interest/focus on ASP.NET and created Xamarin to focus on iOS/Android where ASP.NET bugs were no longer being fixed. So when ServiceStack went commercial in 2013 I decided to abandon Mono and just run it on AWS/Windows/IIS/ASP.NET since a commercial website shouldn't have to put up with random instability/downtime. Then when ServiceStack <a href="https://twitter.com/ServiceStack/status/789142311326326784" rel="nofollow">added support for .NET Core</a> I moved back to Linux/nginx/.NET Core only it was now rock solid and much faster. Through the years my backend technology and Services remained the same, because the APIs were designed correctly, they capture the essence of what's required and are implemented in the simplest way, with intuitive focused libraries that provides a thin typed wrapper over the underlying DB functionality needed, not some heavyweight artificial performance-sucking high-level abstraction that loses flavor over time. So I have zero desire to consider overarchitected complex technologies that exposes an unintuitive surface area that I have no idea what it's doing without debugging in a profiler and wasting time with reading abstraction designer docs.</p>
<p>But hey if EF/OData works for you and you're productive with it, keep using it. I wont dissuade you from using something that you deliver value with, which in the end should be everyone's goal in-spite of our technology choices, so just use what makes you productive &amp; happy.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599614472" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T15:55:02.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <blockquote>
<p>Allowing clients to be able to construct adhoc joins to System tables is even worse tight-coupling, which you have even less hope of being able to make changes without breaking existing clients. Might as well give out an RDBMS connection string and give them maximum flexibility.</p>
</blockquote>
<p>Or in my case ...<br>
Allowing clients to be able to construct adhoc joins to different sets in an API model which isn't the DB Model.<br>
My service layer deals with the translation of questions but much like the layer above it, it can generate some "interesting" questions.</p>
<p>Believe it or not I carry much the same ethos as you but i'm often not in a position to make the "ideal choice" due to external concerns (as described above). I offset a ton of the concerns you have with the nature of the "over-complexity" and "over-engineering" by putting all my business logic behind interfaces and using IoC so if I have OData controllers, WebAPI controllers, or ServiceStack services i'm always insulated from that complexity, but it does make it tricky to answer some of the problems that such implementations introduce.</p>
<p>I've also deliberately put EF behind an Interface which having migrated the stack on to ServiceStack I'm seeing that I did lapse in a couple of places where I exposed IQueryables when I should have exposed IEnumerables (that's on me to fix and trivial to do so).</p>
<p>That said, having taken your advice onboard my plan is to update the code until those "leaks" are plugged then to re-migrate the code again as it only took me a couple days this time round it shouldn't be too bad next time.</p>
<p>I have another major demand on my time this week but hopefully I can get to looking at that stuff next week. The up side is that my business logic architecture is entirely interface / IoC driven so it's mostly a lift and shift operation (i have said I don't use that stuff like most people do).</p>
<p>I do appreciate your advice <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/mythz/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/mythz">@mythz</a>  and you do make some great points, points that I intend to raise with Microsoft too in places because ultimately you're right and it's on them to provide good advice for the technology stacks that so many use.<br>
I also feel in places you over generalise the problem of bad platform design and imply that I as a result have a bad stack that will ultimately need to be rebuilt because of my "assumption OData is a necessary complexity" or "mis-guided impressions", that's not how I work and for that reason my OData API doesn't support the full spec deliberately, and in places actively ignores it.</p>
<p>I would still be interested in looking at ServiceStack but the current feedback from our board of directors is the following ...</p>
<ol>
<li>Who are you / how big is the company as support is a must have for the work we do?</li>
<li>Is there a way to test our complete migrated stack without the cost of a licence fees until we know it works for us?</li>
<li>Is It compatible with the demands our existing clients have?</li>
</ol>
<p>That last point is the one i've been trying to address here of course for the most part.<br>
My current understanding is that it works the way it works and that clients should fall inline with that, which might not be something our clients are willing to accept, but it's extremely flexible so with a bit of work in some cases I should be able to make ServiceStack fit their needs.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599628120" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T16:20:29.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/TehWardy/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TehWardy">@TehWardy</a> If you have to convince a whole board of directors I'd say keep on Microsoft's supported technology stack, they're going to have concerns adopting an alternative .NET technology esp. since most of .NET ecosystem just uses whatever MS puts out. Esp. if they're non-technical, IMO the only way they'll ever consider it, is if you have the freedom to evaluate and compare prototype solutions side-by-side. But if you still want to consider evaluating SS you can request a unrestricted trial license key from <a href="mailto:team@servicestack.net">team@servicestack.net</a>.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-599634709" target="_blank" class="time">
                                    <relative-time datetime="2020-03-16T16:33:54.0000000&#x2B;00:00">
                                        Mar 16, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>I do happen to have that freedom, and as the technical lead here for everything we do the board leans on my guidance to make it's technology spending calls, gneerally speaking the calls made are "because it's right" not out of some mis-guided impression that M$ puts out about how things should be done (hopefully i've shown you that much at least).</p>
<p>Again, Many thanks for the feedback, when I get back to it i'll definitely ping them an email, i'm actually curious to see how the two solutions work side by side because as they say "the proof is in the pudding" ... right!</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">üëç</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
            <p class="text-center">
                <a class="btn btn-primary btn-light btn-lg" target="_blank" href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#new_comment_field"><i class="fab fa-github"></i> Join the discussion at GitHub</a>
            </p>
    </div>
</div>
</main>
<footer class="bg-light py-3 mt-5 text-muted text-center">
  <a href="https://github.com/pauldotknopf/pauldotknopf.github.io"><i class="fab fa-github"></i> source</a>
</footer>
<script src="/dist/scripts.js"></script>
</body>
</html>
