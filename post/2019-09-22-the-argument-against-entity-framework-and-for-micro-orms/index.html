<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The argument against Entity Framework, and for micro-ORMs. - Paul Knopf</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="/dist/styles.css" rel="stylesheet" type="text/css"/>
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112478642-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-112478642-1');
  </script>
</head>
<body>
<header class="bg-light mb-5">
  <div class="navbar navbar-expand">
    <div class="container">
      <a href="/" class="navbar-brand d-flex">
        <strong>paul knopf</strong>
      </a>
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="/archive">archive</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="/about">about</a>
        </li>
      </ul>
    </div>
  </div>
</header>
<main>
  
<div class="container">
    <div class="post">
        <h1 class="title">
            The argument against Entity Framework, and for micro-ORMs.
        </h1>
        <p class="submitted">
            posted on Sep 22, 2019
        </p>
        <div class="content">
            <h1 id="preface">Preface</h1>
<p>I've worked with Entity Framework (since the .NET 3.5 days, both code-first and database-first) as well as the latest .NET Core version. It was my preferred solution for a while and I've gotten pretty good with it. Looking back, I regret having to learn the hard way that EF is very taxing and it just isn't a good choice for most solutions.</p>
<p>There are many ORMs in the .NET world, but I think my point could be made when picking one of each a fully-fledged ORM, and a micro ORM.</p>
<ul>
<li>Full ORM - <a href="https://github.com/aspnet/EntityFrameworkCore">Entity Framework Core</a> - Chosen because it is the unofficial official version for .NET. It is front-and-center in most of the &quot;Getting Started&quot; docs and is what most junior devs will choose when beginning their journey into .NET.</li>
<li>Micro ORM - <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">ServiceStack.OrmLite</a> - For the sake of argument, I could easily have chosen other solutions, such as Dapper or PetaPoco, but I'm a fan of the API/features that ServiceStack.OrmLite provides. <em><strong>NOTE</strong>: OrmLite is free for open-source, but paid for closed-source.</em></li>
</ul>
<h1 id="surface-areaexposure">Surface area/exposure</h1>
<p>As with picking any dependency on your project, you must step back and take a 20,000-foot view of things to determine its impact on your solution. One way to do this is to consider the size of the dependency via the lines-of-code.</p>
<p>Using <code>cloc</code>, here is the overview of the size of each codebase.</p>
<div class="featured-image"><p><img src="/ef-vs-ss.jpg" alt="Entity Framework vs ServiceStack.OrmLite lines of code" /></p>
</div>
<p>Purely considering lines-of-code can be a fool's errand, but there is more to the story here. As the saying goes &quot;more money, more problems&quot;, right? As you increase your surface area (including your dependency graph), you increase your chances of running into bugs/issues. As you sit on top of more layers of abstraction and indirection, the problems that you begin to run into begin to get more cryptic and harder to isolate/fix.</p>
<p>You can get a sense of this by spending a few minutes on the issue pages for each ORM (<a href="https://forums.servicestack.net/c/ormlite">here</a> and <a href="https://github.com/aspnet/EntityFrameworkCore/issues?q=label%3Atype-bug+">here</a>). You'll find that the issues in OrmLite are generally about the problem-domain (getting data in-and-out of the database) or the underlying ADO provider, whereas the issues in EF generally involve the layers/types that are involved in the abstractions.</p>
<p>When it comes to the scope of your dependency and the exposure it brings to your project, I wouldn't take this point lightly. It is often overlooked, and when it does eventually tax your solution, it can go unnoticed/unrealized.</p>
<p>You can't escape the issues of just &quot;getting data in and out&quot; and the underlying database. However, there is a huge swath of issues that can be completely avoided by just choosing not to expose yourself. Smaller targets are harder to hit. Keep your dependencies small.</p>
<h1 id="bare-metal">Bare metal</h1>
<p>Micro ORMS are usually just extensions on top of raw ADO types (<code>IDbCommand</code>, <code>IDbConnection</code>, etc) and OrmLite is no exception. These extensions usually go only so far as to prevent the user from having to manually manage SQL strings, which is an obvious maintenance nightmare.</p>
<p>At this point of abstraction, no real complaints can be made. You get fully type-checked access to your underlying database, with a 1-to-1 relationship between your types and the data they represent. Your data types (POCOs) are expressed clearly. No magic. No voodoo. No &quot;secret&quot; tables for mapping many-to-many relationships. No complex graph management. No virtual proxies and lazy collections. No navigation properties leaked. These things usually end up just adding friction to your project, caking on additional features that silently tax you.</p>
<p>If exceptions happen when using OrmLite (or micro ORMs), they are usually a result of the underlying ADO provider, key constraints, etc. It's better to be closer to the metal when an issue arises because the cause/fix is usually more clear.</p>
<p>A common misconception is that &quot;because you're bare metal, you need more boilerplate!&quot; This just isn't true. I mean, in the case of working with HTTP over a raw TCP connection, of course. You'd want a higher-level abstraction. But this just isn't the case with OrmLite (or Micro ORMs in general). I'd wager that I'd get by with fewer lines of code when using OrmLite over EF.</p>
<p>Let's say you have a business requirement of storing/retrieving data. You've ruled out the need for non-conventional databases (graph, Cassandra, etc) and have decided that a relational database will work. The following code illustrates the <em>bare minimum needed</em> to tackle your problem, using OrmLite.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
    {
        [<span class="hljs-meta">AutoIncrement</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] _</span>)</span>
    {
        <span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteDialect.Provider);

        <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> db = factory.OpenDbConnection())
        {
            db.CreateTable&lt;Person&gt;();

            <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person { Name = <span class="hljs-string">"Paul"</span> };
            <span class="hljs-keyword">var</span> personId = db.Save(person); <span class="hljs-comment">// Id is also auto set.</span>

            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> trans = db.OpenTransaction(IsolationLevel.ReadCommitted))
            { 
                person = db.Single(db.From&lt;Person&gt;().Where(x =&gt; x.Name == <span class="hljs-string">"Paul"</span>));
                person = db.SingleById&lt;Person&gt;(personId);

                person.Name = <span class="hljs-string">"Another name"</span>;

                db.Save(person);

                trans.Commit();
            }
        }
    }
}</code></pre>
<p>Any business requirement can be achieved with the above code. There is little in the way to prevent you from defining your solution/architecture how you'd like. OrmLite (micro ORMs) focus on exactly what is needed to solve your problem. Nothing more, nothing less. This brings me to my next point.</p>
<p>Heavy ORMs impose artificial abstractions that force you into a unique style of development that's introducing a further disconnect and layer of indirection between your code and your database, requiring the usage the usage of augmented and proxied EF-specific models. Using this abstraction isn't going to make you a better OOP of FP programmer or make you more knowledable about SQL or any RDBMS-specific features.</p>
<p>Sitting on EF's layers limits your ability to clearly perdict the behavior and functionality of each query, instead relying on EF-specific behavior. This makes it harder to reason about your code as you'll need to keep a hidden context of the incidental complexity in EF's behavior when reviewing code. You'd have to know exactly EF does, when it does it and why it does it when diagnosting unwanted behavior like unintended data access.</p>
<h1 id="missing-features">Missing features</h1>
<p>I believe I've set a high bar up until this point when it comes to choosing EF over OrmLite, but this doesn't factor the additional features that developers have come to love with EF.</p>
<ul>
<li>Migrations</li>
<li>Change tracking</li>
<li>Unit of work</li>
<li>Lazy collections</li>
<li>Navigation properties (joins and projections)</li>
<li>Result caching</li>
<li>Graph persistence</li>
<li>...the list goes on</li>
</ul>
<p>In my opinion, each of these features is unlikely to address a business concern directly. However, they are still typically highly valued by developers for various reasons.</p>
<p>These features must each be carefully considered. Even if you won't use/benefit from a feature, there is still a cost with having it exist at all. They typically only exist in heavy ORMs (EF) found in enterprise languages (Java/.NET).</p>
<p>I'd prefer to code againt clean APIs that lerverage the DB's underlying functionality and features.</p>
<p>With that said, let me try to address a few of these features.</p>
<h2 id="migrations">Migrations</h2>
<p>Migrations are a requirement of just about every solution. A few things to consider.</p>
<p>First, just because <em>you</em> didn't write the code, doesn't mean <em>someone</em> didn't write the code. Choosing a batteries-included approach doesn't make your solution any simpler. You can put the engine under the hood, or in the trunk, but it will still break down.</p>
<p>Secondly, choosing a batteries-included approach for a one-size-fits-all solution often means that there are additional edge cases for use-cases that just don't apply to you. This may seem irrelevant, but even if you are using 20% of the feature, that doesn't mean you aren't sitting the abstractions needed specifically needed for the other 80% you don't need.</p>
<p>Lastly, what happens when something goes wrong? Things are a lot easier to debug/fix when you own the solution and there isn't any white noise. What happens when you run into an issue like <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12911">this</a>? What about the time spent debugging? Or fixing a database that the migration failed on? At that point, you've already spent more time using a feature that you didn't implement than it would have taken to just implement migrations yourself.</p>
<p>Seriously, write your own migration layer. I wrote this in 3 minutes.</p>
<pre><code class="language-csharp hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>;
        
        <span class="hljs-keyword">int</span> Version { <span class="hljs-keyword">get</span>; }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Migrator</span>
    {
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> OrmLiteConnectionFactory _connectionFactory;
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IList&lt;IMigration&gt; _migrations;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Migrator</span>(<span class="hljs-params">OrmLiteConnectionFactory connectionFactory, IList&lt;IMigration&gt; migrations</span>)</span>
        {
            _connectionFactory = connectionFactory;
            _migrations = migrations;
        }
        
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Migrate</span>(<span class="hljs-params"></span>)</span>
        {
            <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> connection = _connectionFactory.OpenDbConnection())
            {
                connection.CreateTableIfNotExists&lt;Migration&gt;();

                <span class="hljs-keyword">var</span> installedMigrations = connection.Select&lt;Migration&gt;();

                <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> transaction = connection.BeginTransaction())
                {
                    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> migration <span class="hljs-keyword">in</span> _migrations.OrderBy(x =&gt; x.Version))
                    {
                        <span class="hljs-keyword">if</span> (installedMigrations.Any(x =&gt; x.Version == migration.Version))
                        {
                            <span class="hljs-comment">// Already done!</span>
                            <span class="hljs-keyword">continue</span>;
                        }
                        
                        migration.Run(connection);

                        connection.Insert(<span class="hljs-keyword">new</span> Migration
                            {Version = migration.Version, AppliedOn = DateTimeOffset.UtcNow});
                    }
                    
                    transaction.Commit();
                }
            }
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Migration</span>
        {
            [<span class="hljs-meta">AutoIncrement</span>]
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
            
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
            
            <span class="hljs-keyword">public</span> DateTimeOffset AppliedOn { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMigration1</span> : <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>
        {
            <span class="hljs-comment">// Raw and auditable SQL.</span>
            <span class="hljs-comment">// Create tables, add/drop columns, etc.</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version =&gt; <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestMigration2</span> : <span class="hljs-title">IMigration</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Run</span>(<span class="hljs-params">IDbConnection connection</span>)</span>
        {
            <span class="hljs-comment">// Raw and auditable SQL.</span>
            <span class="hljs-comment">// Create tables, add/drop columns, etc.</span>
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Version =&gt; <span class="hljs-number">2</span>;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] _</span>)</span>
    {
        <span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> OrmLiteConnectionFactory(<span class="hljs-string">":memory:"</span>, SqliteDialect.Provider);

       <span class="hljs-keyword">var</span> migrator = <span class="hljs-keyword">new</span> Migrator(factory, <span class="hljs-keyword">new</span> List&lt;IMigration&gt;
       {
           <span class="hljs-keyword">new</span> TestMigration1(),
           <span class="hljs-keyword">new</span> TestMigration2()
       });

       migrator.Migrate();
    }
}</code></pre>
<p>With less than 100 lines of code, you now have a solution that will have near-zero issues. And if there happens to be an issue, there is a good chance that any developer could fix it within minutes. There is no learning curve. No documentation to read. No CLIs to invoke. No hidden tax bill that will paid in the future.</p>
<h2 id="change-tracking">Change tracking</h2>
<blockquote>
<p><a href="https://twitter.com/ardave2002/status/1175119821261819905?s=20">@ardave2002</a>: I find having a giant ball of mutable state with change detection via virtual proxy that spans my application from one edge to the other to provide huge benefits to my ability to reason about code &lt;/s&gt;</p>
</blockquote>
<p>In my opinion, this feature is just annoying. There is a performance overhead that you introduce when using this feature. This causes you to leak concerns into your application layer, adding <code>AsNoTracking()</code> on all of your read-only queries. Also, having ambient state in your application is generally a bad idea. There are risks associated with having the semantics of <code>SaveChanges()</code> differ depending upon factors that are outside scope. It makes things very difficult to reason with at first glance.</p>
<h2 id="unit-of-work">Unit of work</h2>
<p>I have a hard time discussing this feature because people sometimes conflate this pattern with simple transactions, which exist in raw ADO. You will only have issues if you intend to use <code>TransactionScope</code> from EF, which is a little more than a simple transaction. If you don't intend on using this class, then this isn't a missing feature when choosing OrmLite over EF.</p>
<p>But if you need <code>TransactionScope</code>-like behavior, there are multiple ways in which this could be done. First, you could invert the creation of these objects so that implicitly shared/scoped instances can be used for every request. I've also used <code>AsyncLocal</code> successfully to use cached instances of <code>IDbConnection</code> and <code>IDbTransaction</code> for every nested method call. This is something that could be hand-rolled with minimal lines of code, similarly to the migration approach above.</p>
<p>But in the end, this only matters if you intend to use <code>TransactionScope</code>. Otherwise, this isn't a feature you're missing.</p>
<h2 id="lazy-collections">Lazy collections</h2>
<p>This is a feature that can seem appealing at first but can be very problematic. Do you want database queries to happen implicitly in your views? This is compounded when you are enumerating a collection of objects that have nested lazy properties, causing an additional database query for each for loop.</p>
<p>This is just a really bad idea. Define your query model upfront and fully load it to avoid unintended side effects that only show themselves when unbounded collections inevitably grow.</p>
<h1 id="misc">Misc</h1>
<p>What happens when things just are performant with EF? It's great that it allows you to analyze the SQL being executed, but at that point, you are still at the mercy of the underlying SQL generation. You may decide to jump out of EF in these cases and just execute raw SQL, but why even subject yourself to this?</p>
<p>I also don't like hearing the caveats of &quot;if you know how to use it&quot; or &quot;when used right&quot; when describing features of EF. I'm uncomfortable with the idea of playing hot potato with loaded guns, hoping every person catches the gun <em>just right</em>. Not everyone is as knowledgeable as you. Code reviews are a good thing, but <em>depending</em> upon them isn't a good idea. Things get past code reviews. All developers suck, including me and you. Why even risk it?</p>
<h1 id="final-words">Final words</h1>
<p>An ORM should only serve to give you a type-safe approach to writing SQL. Anything else is a tax that gets compounded as your project evolves.</p>
<p>You could use EF and everything turns out just fine, but the standard deviation between success and failure is wide. When you choose a micro ORM, that standard deviation is much smaller.</p>
<p>Quite frankly, you'd be hard-pressed to ever find a business requirement that <em>only</em> EF could solve. The features that EF provides and OrmLite doesn't are welcomed by developers as being time-saving nice-to-haves. However, when you factor in the taxing nature of using such a large framework like EF, you'll spend more time using it than if you were to just keep things minimal and bare-metal. This is especially true for larger projects involving people with ranging experiences.</p>
<p>If you'd like to add anything, please comment. I love the discussion.</p>
<p><strong>Update</strong>: I created <a href="https://github.com/pauldotknopf/sharp-data-access">SharpDataAccess</a>. It is a thin layer that sits on top of ServiceStack.OrmLite that adds migrations and ambient connections/transactions.</p>

        </div>
            <hr />
            <h3>Comments</h3>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Lux44" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/8456057?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Lux44" target="_blank" class="user">Lux44</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-533975148" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T06:34:38.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Thank you for not advocating building queries from strings :).</p>
<p>Change tracking downside of Entity Framework could have an easy enough workaround: use new DBContext for applying changes, then effects are more obvious.</p>
<p>What doesn't have an easy workaround: startup time of Entity Framework, which is quite noticeable in  desktop apps.</p>
<p>Right now is not really a great time to look at EF bug list, or jump into EF, for that matter. The query translator got rewritten, but hasn't really stabilized, as the issue list rightfully indicates. Their test coverage for new/rewritten parts is also not great. "Please try again with nightly builds" has been the standard response for over a month now. Let's hope by the time 3.1 releases in November things have stabilized.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/lufthavn" target="_blank">
                                <img src="https://avatars2.githubusercontent.com/u/7838029?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/lufthavn" target="_blank" class="user">lufthavn</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-533988580" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T07:30:46.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>I stumbled into this article on reddit, and really liked it. I agree with a lot of what you're saying. <g-emoji class="g-emoji" alias="blush" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png">😊</g-emoji><br>
However, the quote you've included in the "Change Tracking" paragraph feels like a straw man. I agree that it can be dangerous to throw around change tracking entities to every corner of your system, and thus lose sight of what actually happening in your system, but I feel like most people know this shouldn't be done, and that if you have this problem in your code base, it might be a code smell.<br>
Currently I like to implement a command-handler approach in my system, where a command corresponds to a particular business concern, and has only one handler, where I centralize the preparation and execution of my business logic.<br>
I agree that the change tracking gets in the way when all you need is to load read-only data for display. Not only that but if you're eager loading, and have only a couple of nested collections in your entities, the amount of data EF is querying the database for can get huge. We recently had to debug this problem where I work. A request for ~1000 entities could result in result sets of well over 100,000 lines. Surely this could be optimized in EF, but when I encounter something like this, I like to take a step back and evaluate the tool we're using.<br>
If you're querying read-only data from the database, what exactly do you need an ORM for? I'd advocate for introducing a micro-ORM (Dapper is my current favorite, but I might check out ServiceStack.OrmLite soon <g-emoji class="g-emoji" alias="wink" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png">😉</g-emoji>). Nobody says you can't use more than one data-access library in your solution.<br>
This approach of using full-fledged ORMs to retrieve and save business entities in your command handlers, and using bare metal ADO.net or a micro-ORM to very efficiently query for read-only data goes very well with the architectural pattern of CQRS, and is why I recommend it a lot to developers who are dealing with large systems and complex domains.</p>
<p>Anyway, the blog post was great, and I generally I agree with you. <g-emoji class="g-emoji" alias="blush" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png">😊</g-emoji> Just don't write ORMs off right of the bat, and consider them as a tool as you would any other dependency in your system.<br>
Hope this brain dump makes to sense anybody. <g-emoji class="g-emoji" alias="sweat_smile" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png">😅</g-emoji></p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">👍</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/sharpninja" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/16146732?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/sharpninja" target="_blank" class="user">sharpninja</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534077664" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T12:30:08.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>This blog post is good up to a certain level of application complexity.  Most large enterprise projects are going to be dealing with data sets with millions of rows of data, with billions of relational outcomes.  Advocating eager loading in such a scenario is non-sense.  EF allows you to cherry pick relationships to eager load when using lazy loading by default.  If you are using a webserver and constantly eager loading large graphs then you are placing a huge burden on the server to load data that gets dumped in the garbage when the controller returns.  If it's a desktop app, you may get away with it for a while, but eventually your app will be holding a couple of gigs of data in RAM and user experience will suffer.  On mobile, you should be just as strict with memory usage as on a REST server.</p>
<p>EF was designed to work in all these scenarios and when used correctly, does so admirably.  Enterprise code bases need consistency and reliability as their top concerns for maintainability.  Designing a system under the assumption that only you or someone of your skill level will be maintaining code is both arrogant and dangerous.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534173305" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:18:12.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>There's other options for ORMs.</p>
<p>For example, Tortuga Chain (which I work on) using database reflection. Rather than just assuming the class exactly matches the table or doing everything using SQL string literals, it compares the table and class definitions at runtime. This dramatically reduces the boilerplate, especially when you don't want every column.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534173775" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:19:30.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Another is SQL Alchemy which allows you to build complex SQL expressions using an object model. Unfortunately it is Python only at this time.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/Grauenwolf" target="_blank">
                                <img src="https://avatars0.githubusercontent.com/u/10627661?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/Grauenwolf" target="_blank" class="user">Grauenwolf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534178201" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T16:30:47.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>Regarding boilerplate, consider this line:</p>
<p>Consider this line:</p>
<pre><code>dataSource.Update("dbo.Person", new { ID = personId, Name = "Another Name"}).Exceute();
</code></pre>
<p>Why can't all ORMs do this? Why do they usually require manually dealing with connections/contexts and an extra round trip to the database just to perform a simple update?</p>
<p>In my opinion, the only time I should see a <code>using</code> statement in my DB code is when I actually need a transaction. And that should only be needed if I'm updating multiple records.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-534266575" target="_blank" class="time">
                                    <relative-time datetime="2019-09-23T20:17:52.0000000&#x2B;00:00">
                                        Sep 23, 2019
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>This is the same Update query in OrmLite:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">db</span>.<span class="pl-en">UpdateOnly</span>(() <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">Person</span> { <span class="pl-smi">Id</span> <span class="pl-k">=</span> <span class="pl-smi">personId</span>, <span class="pl-smi">Name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> });</pre></div>
<p>Which if you prefer you could also update from an anonymous object or untyped Dictionary, e.g:</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-smi">db</span>.<span class="pl-en">Update</span>&lt;<span class="pl-en">Person</span>&gt;(<span class="pl-k">new</span>  { <span class="pl-smi">Id</span> <span class="pl-k">=</span> <span class="pl-smi">personId</span>, <span class="pl-smi">Name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> });

<span class="pl-smi">db</span>.<span class="pl-en">Update</span>&lt;<span class="pl-en">Person</span>&gt;(<span class="pl-k">new</span> <span class="pl-en">Dictionary</span>&lt;<span class="pl-k">string</span>,<span class="pl-k">object</span>&gt; { 
    [<span class="pl-s"><span class="pl-pds">"</span>Id<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-smi">personId</span>, 
    [<span class="pl-s"><span class="pl-pds">"</span>Name<span class="pl-pds">"</span></span>] <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Another Name<span class="pl-pds">"</span></span> 
});</pre></div>
<p>Other <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#update">Update Examples in OrmLite</a>.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">👍</g-emoji> 2
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598156324" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T12:21:18.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>Having read this .... many of the points here are exactly where i'm at right now ... the hidden technical debt, abstraction issues I can't solve, complexity with no explanation, poor performance in scenarios that often seem trivial on face value.</p>
<p>I'm currently looking in to an alternative to EF Core to resolve a ton of issues I have that the EF Core team seems to be either confused about, not interested in, or simply willing to pick at my description rather than focusing on the issue at hand.</p>
<p>The fact is, since EF6, each and every subsequent release has removed or broken functionality that my stack has depended on and i'm sick of swallowing that with the reasoning being "this is the cost of progress".</p>
<p>So here's where i'm at ...<br>
I'm trying to find an alternative that as this blog post states should not be an issue because "there shouldn't be a problem that EF solves that another framework couldn't also solve".</p>
<p>So here's my core functionality requirements from the EF functionality that I currently use ...</p>
<ul>
<li>Mapping LINQ to SQL</li>
<li>Mapping SQL query results to Entities</li>
<li>Managing / migrating the DB (ideally without having to manually crank out SQL myself)</li>
<li>Complex filtration when "nested questions" happen.</li>
</ul>
<p>That last point appears to be the sticking point for most "micro-ORMs" .. the "micro" prefix usually means like with say Dapper that it does the SQL query to Entity mapping but won't do the bit before that to get from the LINQ expression tree to SQL.</p>
<p>Assuming this ORM can handle that I'm looking for examples ofdoing things like applying set filters so I can achieve something like ...</p>
<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> <span class="pl-smi">results</span> <span class="pl-k">=</span> <span class="pl-smi">Db</span>.<span class="pl-en">GetAll</span>&lt;<span class="pl-en">BaseT</span>&gt;()
   .<span class="pl-en">Include</span>(<span class="pl-smi">t</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">t</span>.<span class="pl-smi">Property</span>)
       .<span class="pl-en">ThenInclude</span>(<span class="pl-smi">i</span> <span class="pl-k">=&gt;</span> <span class="pl-smi">i</span>.<span class="pl-smi">SubProperty</span>)
   .<span class="pl-en">ToArray</span>();</pre></div>
<p>... key things to note here that EF solves that I can't seem to find a solution to in other ORM's the include, and then the sub include are both filtered by the relationship but also on filter conditions applied to the table regardless of context in which that table is questioned.</p>
<p>This seems to be a feature missing in all but EF.</p>
<p>Does this ORM support this scenario?</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598162844" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T12:38:44.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p>OrmLite supports <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#reference-support-poco-style">"POCO References"</a> where it lets you load all nested references with its <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#querying-pocos-with-references">Load* APIs</a> whereas all OrmLite's other APIs wont load any nested references, so you can't pick and choose which references you want to load (i.e. without defining different classes with different references), but as all APIs returns POCOs you also have the option to <a href="https://github.com/ServiceStack/ServiceStack.OrmLite#merge-disconnected-poco-result-sets">stitch &amp; merge multiple POCO resultsets together</a>.</p>
<p>Like all of OrmLite APIs they return "disconnected POCOs" so it's not possible to have hidden N+1 queries that could occur when traversing the result set. i.e. you get back your exact POCOs you've defined, not some proxy sub class with injected decorated behavior.</p>
<p>OrmLite also includes typed APIs for inspecting and <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">altering existing schemas</a>. Paul <a href="https://pknopf.com/post/2019-09-22-the-argument-against-entity-framework-and-for-micro-orms/#migrations" rel="nofollow">outlines a good migration solution</a> on his blog, there's also a few different migration solutions in this <a href="https://forums.servicestack.net/t/any-recommendations-for-maintaining-database-schemas/3304" rel="nofollow">Customer Forums Thread</a>.</p>
<p>I'd recommend reading the <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite docs on its home page</a> which documents its many features.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/TehWardy" target="_blank">
                                <img src="https://avatars3.githubusercontent.com/u/6891030?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/TehWardy" target="_blank" class="user">TehWardy</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598318280" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T17:34:32.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>This requires you to know all the possible combinations of questions that you might want to ask the api up front or manually wiring up a second model so that the traversal is possible with sub queries.<br>
That's never a desired result when you have a db with potentially billions of rows to manage and you want a joned set of maybe 1,000 of them from the results of a single dynamically generated SQL query.</p>
<p>Consider putting an OrmLite managed DB behind an OData API where the questions are virtually limitless but every possible combination of scenarios has to be considered and handled.<br>
With EF this is trivial as I can tell EF that the Set has a filter and then any time EF sees any portion of a linq query hitting a given table it applies the filter then the requested query to the SQL query.</p>
<p>People often forget about the complexity that EF is solving stating that something is a "micro-ORM" instead of a "full ORM" is seemingly just like declaring "this solves half your issue, now go find something else that solves the other half, but it's fast ok".</p>
<p>I've not yet found anything that can match this type of EF solved scenario that didn't require a crap ton of "work arounds" or "patching stuff together" and it's the one thing that keeps my solutions sat on it ... which is frustrating because I both hate it and have to use it at the same time as there is seemingly no alternative.</p>
<p>Other things of note ...</p>
<ul>
<li>For some reason Code generation is seen as bad</li>
<li>Designer tooling focus is seen as bad</li>
</ul>
<p>... all features that I often use to solve dynamic scenarios that would otherwise be unsolvable or for situations like I don't want to sit around writing boiler plate stuff like the SQL statement for building a table when I have a class that exactly matches it's structure.</p>
<p>Also, the current version of EF core will never return "some proxy sub class with injected decorated behavior", as that functionality was ripped out as part of the rebuild when EF6 became EF Core 1.0.</p>
<p>My current entity model, has a DbContext as you might expect with entity sets, none of which I pull from the Db in such a manner that I use things like Lazy loading, or proxies, or in any way require the resulting entities to be "attached" to the context, this is basically the same setup as is explained here.</p>
<p>My ideal ORM would allow me to do something like ...</p>
<pre><code>using(var db = new factory.GetConnection("db name"))
{
       IQueryable&lt;T&gt; results = new Query&lt;T&gt;().Where(...).Select(...).Include(...).OrderBy();
}
</code></pre>
<p>... in this situation I would be constructing a simple ADO.Net connection to the Db and then telling the framework "build me a SQL query of Type T", large complex "models" seem to feel like overkill for me since the type metadata for the query you're building should tell you all you need to know.</p>
<p>I continue my composition on that to construct the full query, including notifying it (as per my previous comment) of what "sub sets" I want in the results, then performing a .ToArray()  .ToList() or simply iterating over it would actually execute it.</p>
<p>The results would be disconnected from the DB (simple POCO's) and be appropriately secured unless I specifically asked the framework to track changes for me to make saving easier later.<br>
If a calling user asks for "select * from Table" configuration of a secure where clause should be a key feature of any ORM "micro" or not.</p>
<p>My issue tends to boil down to the fact that all these ORM's claiming to be better than EF appear to be so on face value, but as soon as you start drilling in to the complex scenarios they fall short of features resulting in me having to extend or build tons of framework around the ORM.</p>
<p>So the article makes the comparison of OrmLite's 89k cloc to EF's 514k cloc in the chart at the begining but it's forgetting that there's a bunch of stuff in that extra 400k cloc that OrmLite can't do.</p>
<p>Unless i'm missing something?</p>
<p>I recently asked the Dapper guys about how implementing a Dapper based back end for OData might look I simply got a one liner "you'd have to write your own version of LINQ to SQL as Dapper doesn't do that" ...</p>
<p>So Dapper can execute a query, and map the results to an Object graph, but it can't build the query in the first place. That's half the work is it not?</p>
<p><strong>In short</strong></p>
<p>I'd love to see a "micro-ORM" implementation of an OData or GraphQL or similar API model as those sorts of API's really push the limits of what ORM's can do.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">👍</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/pauldotknopf" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/523150?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/pauldotknopf" target="_blank" class="user">pauldotknopf</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598345543" target="_blank" class="time">
                                    <relative-time datetime="2020-03-12T18:17:11.0000000&#x2B;00:00">
                                        Mar 12, 2020
                                    </relative-time>
                                </a>&nbsp;
                            </div>
                            <div class="body">
                                <p>See this: <a href="https://docs.servicestack.net/why-not-odata" rel="nofollow">Why not OData?</a></p>
<p>Also this: <a href="https://docs.servicestack.net/autoquery" rel="nofollow">AutoQuery</a></p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="comment">
                        <div class="comment-user">
                            <a href="https://github.com/mythz" target="_blank">
                                <img src="https://avatars1.githubusercontent.com/u/89361?v=4"/>
                            </a>
                        </div>
                        <div class="comment-main">
                            <div class="header">
                                <a href="https://github.com/mythz" target="_blank" class="user">mythz</a> commented
                                <a href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#issuecomment-598525437" target="_blank" class="time">
                                    <relative-time datetime="2020-03-13T03:03:09.0000000&#x2B;00:00">
                                        Mar 13, 2020
                                    </relative-time>
                                </a>&nbsp;(edited)
                            </div>
                            <div class="body">
                                <p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/TehWardy/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/TehWardy">@TehWardy</a> You're living under the misguided assumption that EF's complexity is necessary, it's absolutely not, you have more flexibility and freedom with a typed ORM which gives you direct, clean access to RDBMS features, not some App-level Object Mapping framework that you're a slave to. Doesn't look like you've noticed that none of the new &amp; modern NoSQL data persistence technologies have anywhere the complexity, tracking and impedance mismatch of Heavy ORMs. Something other thriving OSS platforms are aware as their popular ORMs do not suffer EF's complexity tax. They provide straight-forward APIs to access their underlying features, essentially the goal of most API libraries which provide typed APIs to a networked resource, for some reason Heavy ORMs is the only Exception which some ("enterprise" .NET/Java) devs seem to cling on to as the only one true way they could ever envisage code could ever interact with a database.</p>
<p>Your ideal ORM API is not my ideal ORM API which is to provide a clean typed API over RDBMS queries so you know exactly the SQL that's going to be executed - i.e. exactly what OrmLite does where its abstraction is only concerned about offering cross-RDBMS compatible implementation for portability + simplified UX, not some hidden N+1 + tracking magic that EF deems appropriate.</p>
<p>Your OData is a great example of unnecessary complexity, pure unnecessary bloat, resulting in slow, implementation coupled APIs that you haven't got a dream of feasibly being able refactor &amp; replace its implementation without breaking external clients - effectively breaking the golden rule of API design. Read Paul's links if you want to see how you can build a simpler, cleaner &amp; faster data-driven services using a Micro ORM (OrmLite) without any of the pitfalls of OData. It's no wonder Netflix abandoned their failed experiment with it and any company that cares about performance wont go near it.</p>
<p>Happy that you're productive with EF, but you've got very little chance in convincing many devs that have made the switch to Micro ORMs that Heavy ORMs are still the ultimate sophistication of how a ORM should be designed an implemented - many of us came from there, we're not going back.</p>
                            </div>
                            <div class="footer">
                                <ul class="nav">
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="+1" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png" class="emoji">👍</g-emoji> 1
                                            </a>
                                        </li>
                                        <li class="nav-item">
                                            <a class="nav-link active" href="#">
                                                <g-emoji alias="heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png" class="emoji">❤️</g-emoji> 1
                                            </a>
                                        </li>
                                </ul>
                            </div>
                        </div>
                    </div>
            <p class="text-center">
                <a class="btn btn-primary btn-light btn-lg" target="_blank" href="https://github.com/pauldotknopf/pauldotknopf.github.io/issues/12#new_comment_field"><i class="fab fa-github"></i> Join the discussion at GitHub</a>
            </p>
    </div>
</div>
</main>
<footer class="bg-light py-3 mt-5 text-muted text-center">
  <a href="https://github.com/pauldotknopf/pauldotknopf.github.io"><i class="fab fa-github"></i> source</a>
</footer>
<script src="/dist/scripts.js"></script>
</body>
</html>
